1
0:0:0,54 --> 0:0:1,2
Hello

2
0:0:1,2 --> 0:0:1,38
大家好

3
0:0:1,38 --> 0:0:1,94
我是Mark

4
0:0:1,94 --> 0:0:3,48
今天跟大家分享一道面试题

5
0:0:3,48 --> 0:0:7,92
如何定义只能在堆上或站上生成对象的类

6
0:0:7,92 --> 0:0:10,93
这个面试题呢是一个非常经典的面试题

7
0:0:10,93 --> 0:0:14,51
在腾讯和抖音都有问到这个问题

8
0:0:14,51 --> 0:0:17,8
我们首先来思考一下如何来进行破局

9
0:0:17,8 --> 0:0:20,4
在运行时能不能解决这个问题呢

10
0:0:20,4 --> 0:0:23,9
在运行时就算能够解决这个问题

11
0:0:23,9 --> 0:0:24,89
那通常一旦出现问题

12
0:0:24,89 --> 0:0:26,31
就有可能引起崩溃

13
0:0:26,31 --> 0:0:29,57
所以呢我们考虑的是在编译期解决这个问题

14
0:0:29,57 --> 0:0:30,37
也就是呢

15
0:0:30,37 --> 0:0:33,67
如果只能够在堆上去创建这个对象的话

16
0:0:33,67 --> 0:0:35,49
那么在站上去创建对象

17
0:0:35,49 --> 0:0:38,26
我们在编译期就要让他进行报错

18
0:0:38,26 --> 0:0:40,98
同理在站只能够在栈上的话

19
0:0:40,98 --> 0:0:43,4
那在堆上进行分配内存

20
0:0:43,4 --> 0:0:45,8
我们就让它进行一个编译报错

21
0:0:45,8 --> 0:0:45,76
那这样子呢

22
0:0:45,76 --> 0:0:48,4
我们就可以比较完善的解决这个问题

23
0:0:48,4 --> 0:0:51,8
现在我们来逐步解决这个问题

24
0:0:51,8 --> 0:0:54,48
先来看第一个只能在堆上生成对象的类

25
0:0:54,48 --> 0:0:57,54
意味着不能够在栈上生成对象的类

26
0:0:57,54 --> 0:0:59,42
我们首先考虑到的是

27
0:0:59,42 --> 0:1:1,68
把这个构造函数进行私有化

28
0:1:1,68 --> 0:1:3,42
因为呢你在站上的时候

29
0:1:3,42 --> 0:1:5,12
你去声明这个对象的时候

30
0:1:5,12 --> 0:1:6,5
他就会去调构造函数

31
0:1:6,5 --> 0:1:8,92
那么我让你不能够调构造函数

32
0:1:8,92 --> 0:1:11,68
看能否解决这个问题

33
0:1:20,96 --> 0:1:25,77
首先我们把这个构造函数进行私有化

34
0:1:25,77 --> 0:1:28,73
析构函数呢我们仍然

35
0:1:35,18 --> 0:1:36,52
在公有

36
0:1:36,52 --> 0:1:39,64
那么现在你的构造函数是私有的

37
0:1:39,64 --> 0:1:41,96
你要在堆上生成这个对象

38
0:1:41,96 --> 0:1:45,72
那所以呢我们需要提供提供一个方法

39
0:1:45,72 --> 0:1:48,3
来进行创建

40
0:1:48,3 --> 0:1:51,55
这种方法呢我相信大家应该比较熟悉啊

41
0:1:51,55 --> 0:1:53,7
比如说在单例模式当中

42
0:1:53,7 --> 0:1:55,66
我们是采用这种方式来进行生成对象

43
0:1:55,66 --> 0:1:57,62
还有一个呢就是在工厂模式当中

44
0:1:57,62 --> 0:2:1,36
我们也是通过一个函数来生成一个比较复杂

45
0:2:1,36 --> 0:2:3,54
构建过程的一个类

46
0:2:4,74 --> 0:2:7,6
那么这样子我们是否解决问题了呢

47
0:2:7,6 --> 0:2:8,34
我们来写测试代码

48
0:2:8,34 --> 0:2:9,22
大家就知道了

49
0:2:9,22 --> 0:2:11,3
首先不能够在站上生成

50
0:2:11,3 --> 0:2:13,64
我们用hip only

51
0:2:16,12 --> 0:2:17,16
好object

52
0:2:18,2 --> 0:2:18,84
大家看

53
0:2:18,84 --> 0:2:23,74
可以看到这里呢调用了一个私有的构造函数

54
0:2:23,74 --> 0:2:24,68
它是报错的

55
0:2:24,68 --> 0:2:26,86
所以呢好像是可以解决问题

56
0:2:26,86 --> 0:2:29,3
接下来我们再来看一下

57
0:2:29,54 --> 0:2:31,34
我们先在堆上来创建

58
0:2:31,34 --> 0:2:33,3
看堆上是否可以产生

59
0:2:33,3 --> 0:2:34,4
可以对不对

60
0:2:34,4 --> 0:2:34,78
好

61
0:2:34,78 --> 0:2:39,37
我们也可以仅直接进行delete释放这个内存啊

62
0:2:39,37 --> 0:2:40,67
这个也是可以的

63
0:2:40,67 --> 0:2:42,57
好然后我们再来看一下

64
0:2:42,57 --> 0:2:46,63
这里呢我们只考虑到私有的一个构造

65
0:2:46,63 --> 0:2:48,57
那如果我们进行拷贝构造呢

66
0:2:48,57 --> 0:2:50,89
它仍然是站上的对象啊

67
0:2:51,44 --> 0:2:52,74
比如说我们是这样子的

68
0:2:52,74 --> 0:2:53,24
Object

69
0:2:53,24 --> 0:2:58,39
一等于我通过上面堆上的资源呢

70
0:2:58,39 --> 0:3:0,659
去进行一个构建拷贝构造

71
0:3:0,659 --> 0:3:2,439
大家可以看到它是可以的

72
0:3:2,439 --> 0:3:4,11
因为这个对象可以产生

73
0:3:4,11 --> 0:3:7,57
同时它的析构函数呢也可以被调用到

74
0:3:7,57 --> 0:3:9,56
所以它是可以解决问题的

75
0:3:9,56 --> 0:3:10,54
那么大家会哦

76
0:3:10,54 --> 0:3:11,64
它是有问题的

77
0:3:11,64 --> 0:3:14,73
因为呢它在站上确实生成了这样的一个类

78
0:3:14,73 --> 0:3:17,81
那我们在这个基础上还需要加一个代码

79
0:3:17,81 --> 0:3:21,57
就是进行禁止拷贝构造

80
0:3:25,88 --> 0:3:31,64
好同时呢进行禁用我们的拷贝赋值运算符

81
0:3:31,64 --> 0:3:33,2
我们用delete的方式

82
0:3:33,2 --> 0:3:35,8
那么这种方式呢大家可会发现呢它就不可以了

83
0:3:35,8 --> 0:3:37,85
现在这这里报错了

84
0:3:37,85 --> 0:3:38,27
好

85
0:3:38,27 --> 0:3:42,86
我们已经delete的一个我们的拷贝构造

86
0:3:42,86 --> 0:3:45,83
这个呢是一种拷贝构造好

87
0:3:45,83 --> 0:3:47,5
那么大家会发现呢

88
0:3:47,5 --> 0:3:52,51
我们从技术上可以通过私有构造以及禁用

89
0:3:59,2 --> 0:4:2,8
禁用拷贝构造的方式呢可以解决这个问题

90
0:4:2,8 --> 0:4:4,28
这是从功能上

91
0:4:4,28 --> 0:4:5,76
那如果从设计上呢

92
0:4:5,76 --> 0:4:10,12
从设计上我们通常delete它对应的操作呢是new操作

93
0:4:10,12 --> 0:4:13,24
所以呢这种方式是违反我们的直觉的

94
0:4:13,24 --> 0:4:17,18
也就是从设计层面是违违反直觉的

95
0:4:17,18 --> 0:4:19,38
所以这种方式呢不是特别好

96
0:4:19,38 --> 0:4:21,72
然后我们先来思考一下

97
0:4:21,72 --> 0:4:25,41
既然私有构造这种方式不太好

98
0:4:25,41 --> 0:4:26,49
那么我们再来看一下

99
0:4:26,49 --> 0:4:28,79
私有析构是否可以解决这个问题呢

100
0:4:28,79 --> 0:4:31,41
首先我们来尝试着了解一下

101
0:4:31,41 --> 0:4:34,34
私有析构能不能够解决问题

102
0:4:34,34 --> 0:4:39,849
因为大家考虑一下在站上生成这个对象

103
0:4:39,849 --> 0:4:43,469
然后这个站上的对象走出生命周期的时候

104
0:4:43,469 --> 0:4:45,7
会调用析构函数

105
0:4:45,7 --> 0:4:48,25
那编译器呢就会在走出生命周期的那个位置呢

106
0:4:48,25 --> 0:4:50,49
插入我们这个对象的析构函数

107
0:4:50,49 --> 0:4:53,179
但是呢发现这个析构函数是私有的

108
0:4:53,179 --> 0:4:55,859
违反我们的控制访问控制规则

109
0:4:55,859 --> 0:4:57,69
那就会进行编译报错

110
0:4:57,69 --> 0:4:59,3
也就是从原理上

111
0:4:59,3 --> 0:5:1,37
好像私有虚构是可以解决问题的

112
0:5:1,37 --> 0:5:5,2
那么我们现在来还是开始尝试写代码

113
0:5:5,14 --> 0:5:8,26
先把上面的测试呢进行注释

114
0:5:14,92 --> 0:5:17,48
现在我们把析构函数

115
0:5:24,16 --> 0:5:27,32
构造函数呢仍然是在public下面

116
0:5:29,82 --> 0:5:32,66
因为这里是析构函数

117
0:5:32,66 --> 0:5:35,42
那我们就不能够直接去调delete了

118
0:5:35,42 --> 0:5:37,74
因为他们访问不了他的析构函数

119
0:5:37,74 --> 0:5:39,72
所以我们需要提供一个函数

120
0:5:39,72 --> 0:5:40,76
提供一个函数

121
0:5:40,76 --> 0:5:43,56
大家注意我们不能够用静态的函数

122
0:5:47,1 --> 0:5:50,36
因为静态的函数呢它不能够访问this指针

123
0:5:50,36 --> 0:5:52,86
我们这里呢要进行一个delete this

124
0:5:53,86 --> 0:5:55,39
大家需要注意呃

125
0:5:55,39 --> 0:5:57,39
我们刚刚这里呢是私有的

126
0:5:57,39 --> 0:6:1,32
但是呢我们可以在静态的成员函数当中

127
0:6:1,32 --> 0:6:3,2
去new这个对象

128
0:6:3,2 --> 0:6:4,92
这个呢是一个访问规则

129
0:6:4,92 --> 0:6:8,3
访问规则呢就是类的成员函数

130
0:6:8,3 --> 0:6:11,919
包括静态成员函数是可以访问本类的所有成员

131
0:6:11,919 --> 0:6:15,79
因为呢访问控制它是针对类而言的

132
0:6:15,79 --> 0:6:17,1
而不是针对对象而言的

133
0:6:17,1 --> 0:6:18,4
大家需要注意

134
0:6:18,4 --> 0:6:20,0
所以呢我们在静态成员函数当中呢

135
0:6:20,0 --> 0:6:22,36
仍然可以访问本类的所有成员

136
0:6:22,36 --> 0:6:24,32
包括私有成员

137
0:6:24,97 --> 0:6:26,81
当然在类的成员函数当中呢

138
0:6:26,81 --> 0:6:30,33
可以访问本类其他对象的私有成员

139
0:6:31,88 --> 0:6:36,22
接下来我们再来看这里呢提供了一个destroy

140
0:6:36,22 --> 0:6:38,72
接下来我们写测试案例

141
0:6:40,2 --> 0:6:44,3
同样的我们先去在堆上呢生成这样的一个对象

142
0:6:44,3 --> 0:6:47,1
那释放的时候呢就通过destroy

143
0:6:47,1 --> 0:6:51,8
那我现在能不能够去产生一个对象呢

144
0:6:51,64 --> 0:6:55,8
在堆上在站上能不能产生一个对象的object3好

145
0:6:55,8 --> 0:6:58,18
大家会发现它会进行一个报错

146
0:6:58,18 --> 0:7:0,7
Hip only has private destructor

147
0:7:0,7 --> 0:7:3,54
也就是我们这里呢有一个私有的析构函数

148
0:7:3,54 --> 0:7:4,97
在调用呃

149
0:7:4,97 --> 0:7:6,91
所以呢它会进行一个报错

150
0:7:6,91 --> 0:7:9,89
那能不能够去进行拷贝呢

151
0:7:9,89 --> 0:7:11,78
拷贝也不行

152
0:7:11,78 --> 0:7:12,94
拷贝的时候

153
0:7:12,94 --> 0:7:15,5
因为object3它虽然生成了这个对象

154
0:7:15,5 --> 0:7:17,82
但是它生命周期走出来的时候呢

155
0:7:17,82 --> 0:7:19,98
我们的编译器会插入析构函数

156
0:7:19,98 --> 0:7:21,8
但是呢析构函数是私有的

157
0:7:21,8 --> 0:7:24,3
所以object3它仍然没法析构

158
0:7:24,3 --> 0:7:25,95
所以也会报错

159
0:7:25,95 --> 0:7:27,29
那大家会发现呢

160
0:7:27,29 --> 0:7:31,45
就是我们采用析构函数也可以解决这个问题

161
0:7:31,45 --> 0:7:33,69
但是我们从设计层面上

162
0:7:33,69 --> 0:7:35,87
它仍然违反我们的直觉

163
0:7:35,87 --> 0:7:38,35
因为我们用new对应的就是用delete

164
0:7:38,35 --> 0:7:41,15
现在呢我们必须要用一个成员函数来进行

165
0:7:41,15 --> 0:7:42,13
释放对象

166
0:7:42,13 --> 0:7:44,75
所以这种方式呢也不是很好

167
0:7:44,75 --> 0:7:47,73
那么我们就需要考虑一个最佳实践的问题

168
0:7:47,73 --> 0:7:48,97
最佳时间的问题呢

169
0:7:48,97 --> 0:7:52,53
就是我们把它两者呢都进行一个融合

170
0:7:54,1 --> 0:7:57,18
好我们先把这种代码的先进行注释

171
0:7:58,46 --> 0:8:0,82
包括测试案例也进行注释

172
0:8:6,7 --> 0:8:9,14
构造和析构全部进行私有化

173
0:8:10,22 --> 0:8:11,58
同时

174
0:8:13,54 --> 0:8:17,12
我们需要通过一个静态的成员函数

175
0:8:17,12 --> 0:8:19,24
来生成我们的对象

176
0:8:19,24 --> 0:8:23,239
同时通过一个destroy

177
0:8:23,239 --> 0:8:27,359
一个成员函数去释放对象

178
0:8:28,38 --> 0:8:34,3
好同时呢我们把拷贝构造呢去进行一个禁用好

179
0:8:34,3 --> 0:8:36,63
那么这样子呢就形成了一个最佳实践

180
0:8:36,63 --> 0:8:39,799
我们接下来进行一个测试

181
0:8:40,279 --> 0:8:42,399
比如说把这里的代码来进行一个测试

182
0:8:42,399 --> 0:8:44,719
看能否解决问题

183
0:8:50,48 --> 0:8:52,12
好大家看到这样子的

184
0:8:52,12 --> 0:8:55,31
从设计层面他就不会违反我们的直觉了

185
0:8:55,31 --> 0:8:57,69
通过great来进行创建对象

186
0:8:57,69 --> 0:9:0,15
然后呢通过这个对象调一个成员函数呢

187
0:9:0,15 --> 0:9:1,43
进行析构销毁

188
0:9:1,43 --> 0:9:4,329
所以呢他是满足我们的条件的好

189
0:9:4,329 --> 0:9:7,769
接下来大家可以看到我们能否通过拷贝构造呢

190
0:9:7,769 --> 0:9:8,529
也不可以

191
0:9:8,529 --> 0:9:8,869
对不对

192
0:9:8,869 --> 0:9:9,689
也不可以

193
0:9:9,689 --> 0:9:12,87
所以我们的问题得到完美解决

194
0:9:13,27 --> 0:9:15,57
当然呢还会有一个更好的方式

195
0:9:15,57 --> 0:9:18,23
因为有的时候呢我们不想调这个destroy

196
0:9:18,23 --> 0:9:19,22
那怎么办呢

197
0:9:19,22 --> 0:9:23,14
好我们可以把这个great呢再进行一个改造

198
0:9:24,74 --> 0:9:28,96
我们给它进行返回一个unique pdr

199
0:9:33,78 --> 0:9:38,86
好我们去返回一个new的这样的一个对象

200
0:9:38,86 --> 0:9:42,359
同时我们这里呢大家需要注意

201
0:9:43,7 --> 0:9:46,71
我们这里定义自定义一个删除器

202
0:9:48,4 --> 0:9:49,84
自定义一个删除器

203
0:9:51,8 --> 0:9:53,84
啊这个呢是用来接收this指针

204
0:9:55,8 --> 0:9:58,66
然后后面呢添加一个destroy

205
0:10:0,12 --> 0:10:3,12
好通过一个lambda表达式来返回

206
0:10:10,4 --> 0:10:13,88
然后这个P呢去掉destroy

207
0:10:20,2 --> 0:10:23,94
好那么这种方式呢通过这样great创建这个对象

208
0:10:23,94 --> 0:10:27,34
那么当这个unique ptr的所对应的对象

209
0:10:27,34 --> 0:10:28,74
走出生命周期的时候

210
0:10:28,74 --> 0:10:30,9
就会自动去掉这个析构函数

211
0:10:30,9 --> 0:10:33,58
这个析构函数呢就会去调这个destroy啊

212
0:10:33,58 --> 0:10:34,96
就调这个删除器

213
0:10:34,96 --> 0:10:37,12
删除器呢就会去调这个destroy

214
0:10:37,12 --> 0:10:41,45
那么这样子呢就是一个更好的一个最佳实践了

215
0:10:41,45 --> 0:10:45,86
好关于只能在堆上生成对象的类呢

216
0:10:45,86 --> 0:10:47,42
我们就跟大家介绍到这

217
0:10:47,42 --> 0:10:49,609
我们有多种方式

218
0:10:49,929 --> 0:10:53,409
有私有构造加上禁用拷贝构造

219
0:10:53,409 --> 0:10:54,489
它可以解决

220
0:10:54,489 --> 0:10:57,3
但是这是从功能上实现是可以的

221
0:10:57,3 --> 0:10:59,26
另外一个更精简的做法

222
0:10:59,26 --> 0:11:1,64
就是私有析构函数就可以了

223
0:11:1,64 --> 0:11:4,89
但是呢它仍然是违反我们的直觉的

224
0:11:4,89 --> 0:11:6,93
那接下来呢一个最佳实践呢

225
0:11:6,93 --> 0:11:8,91
就是我们直接通过great

226
0:11:8,91 --> 0:11:11,29
像工厂方法一样去创建这个对象

227
0:11:11,29 --> 0:11:14,19
然后调用成员函数进行一个虚构

228
0:11:14,19 --> 0:11:15,54
这个是可以

229
0:11:15,54 --> 0:11:18,87
但是有的时候呢我们忘记去掉destroy啊

230
0:11:18,87 --> 0:11:21,55
我们可以通过智能指针的方式来进行管理

231
0:11:21,55 --> 0:11:23,95
然后我们这里呢借助了一个unique pdr

232
0:11:23,95 --> 0:11:25,22
删除器的方式

233
0:11:25,22 --> 0:11:28,17
在删除器当中呢我们去调destroy

234
0:11:28,17 --> 0:11:29,11
那么这样子呢

235
0:11:29,11 --> 0:11:31,89
我们就可以更好的去使用这个hip hoonly

236
0:11:31,89 --> 0:11:34,47
而且呢通过这个智能指针啊

237
0:11:34,47 --> 0:11:36,51
我们可以进行资源转移

238
0:11:36,51 --> 0:11:39,13
我们这里呢就不需要去写那个啊

239
0:11:39,13 --> 0:11:43,3
移动构造和移动赋值构造了好

240
0:11:43,3 --> 0:11:44,69
接下来我们再来看一下

241
0:11:44,69 --> 0:11:47,39
只能够在栈上生成对象的类

242
0:11:47,39 --> 0:11:50,51
那意味着不能够在堆上生成对象的类

243
0:11:50,51 --> 0:11:52,98
那我们应该怎么解决呢

244
0:11:53,46 --> 0:11:55,72
在不能够在堆上生成

245
0:11:55,72 --> 0:11:57,18
堆上生成对象

246
0:11:57,18 --> 0:12:2,72
首先是不是应该要调new在堆上分配资源好

247
0:12:2,72 --> 0:12:5,74
那么还有一种呢就是我们可以通过MALLOC

248
0:12:5,74 --> 0:12:8,94
然后加上placement new

249
0:12:8,94 --> 0:12:9,38
好

250
0:12:9,38 --> 0:12:12,28
有这两种方式呢去堆上生成类

251
0:12:12,28 --> 0:12:14,2
我们先考虑这个new

252
0:12:14,2 --> 0:12:16,57
你在堆上生成的时候呢

253
0:12:16,57 --> 0:12:18,25
先需要通过new来生成对象

254
0:12:18,25 --> 0:12:21,4
那我直接禁用这个new操作不就可以了吗

255
0:12:21,4 --> 0:12:25,4
好那么我们先来看一下这个new怎么来做

256
0:12:26,18 --> 0:12:28,14
好3km

257
0:12:31,68 --> 0:12:35,6
我们现在呢只需要去禁用一些内容就行了

258
0:12:35,6 --> 0:12:37,24
构造函数用默认的

259
0:12:37,24 --> 0:12:39,8
析构函数用默认的

260
0:12:39,8 --> 0:12:40,7
然后呢禁用

261
0:12:43,22 --> 0:12:46,42
operator new好size

262
0:12:46,42 --> 0:12:50,39
杠T等于delete

263
0:12:50,79 --> 0:12:53,41
同时呢我们也需要去禁用

264
0:12:53,41 --> 0:12:55,63
因为它可能去生成数组

265
0:12:55,63 --> 0:12:57,35
也有可能好

266
0:12:57,35 --> 0:12:58,82
New

267
0:13:0,5 --> 0:13:2,32
堆上创建数组对象

268
0:13:2,32 --> 0:13:4,42
把它进行一个析构

269
0:13:5,61 --> 0:13:8,39
好但是呢大家需要注意这种方式

270
0:13:8,39 --> 0:13:11,4
它是可以解决我们的问题的

271
0:13:11,4 --> 0:13:12,16
我们刚刚有跟大家说

272
0:13:12,16 --> 0:13:14,74
在这里呢它可能是通过MALLOC

273
0:13:14,74 --> 0:13:18,4
然后再加上一个placement new

274
0:13:19,36 --> 0:13:20,84
来进行解决

275
0:13:20,84 --> 0:13:23,43
它也是在堆上生成资源

276
0:13:23,43 --> 0:13:26,9
但是这种方式呢我们也想要禁用它

277
0:13:26,9 --> 0:13:26,99
怎么办呢

278
0:13:26,99 --> 0:13:29,99
好我们可以禁用placement new

279
0:13:29,99 --> 0:13:32,47
怎么禁用placement new呢

280
0:13:36,79 --> 0:13:38,39
好这里已经出来了

281
0:13:38,39 --> 0:13:41,87
好我们禁用placement new

282
0:13:43,48 --> 0:13:46,37
这个呢是禁用呃

283
0:13:46,37 --> 0:13:47,13
Placement new

284
0:13:47,13 --> 0:13:48,85
这个呢是禁用new操作

285
0:13:48,85 --> 0:13:49,85
那么这样子

286
0:13:49,85 --> 0:13:52,89
他就不可能在我们的堆上生成对象了

287
0:13:52,89 --> 0:13:55,224
好我们现在来可以测试一下

288
0:14:2,88 --> 0:14:5,4
好在站上没有问题啊

289
0:14:5,4 --> 0:14:6,94
我们在堆上我们试一下

290
0:14:6,94 --> 0:14:10,9
大家会发现呢这个new会报错啊

291
0:14:10,9 --> 0:14:12,79
还有一个呢就是通过MADOG呢也是一样的

292
0:14:12,79 --> 0:14:15,88
大家呢也会发现它会出现问题好

293
0:14:15,88 --> 0:14:17,12
那么关于这个代码呢

294
0:14:17,12 --> 0:14:18,76
我们先跟大家写到这

295
0:14:18,76 --> 0:14:20,76
然后现在我们开始来进行总结

296
0:14:20,76 --> 0:14:24,349
我们在面试当中应该怎么回答这个问题

297
0:14:24,949 --> 0:14:28,409
如何定义只能够在堆上生成对象的类呢

298
0:14:28,409 --> 0:14:33,13
我们先可以说核心思路最精简的做法

299
0:14:33,13 --> 0:14:35,46
就是私有析构函数

300
0:14:35,46 --> 0:14:40,2
那具体的步骤呢就是把析构函数设置为private

301
0:14:40,2 --> 0:14:43,6
或者是protected也是可以的

302
0:14:43,6 --> 0:14:47,82
然后我们通过public当中的一个静态方法

303
0:14:47,82 --> 0:14:53,4
来返回我们堆上就是new创建的对象指针

304
0:14:53,4 --> 0:14:55,58
然后还需要提供一个方法

305
0:14:55,58 --> 0:14:59,52
就是提供一个destroy去进行一个析构

306
0:15:0,24 --> 0:15:1,76
具体的原理是什么呢

307
0:15:1,76 --> 0:15:4,92
就是我们的站对象走出生命周期的时候

308
0:15:4,92 --> 0:15:7,15
他是需要调用析构函数的

309
0:15:7,15 --> 0:15:9,35
但是呢析构函数私有化了

310
0:15:9,35 --> 0:15:11,21
编译器没法访问

311
0:15:11,21 --> 0:15:13,62
所以呢会造成编译错误

312
0:15:13,62 --> 0:15:15,56
这样子呢就可以解决

313
0:15:15,56 --> 0:15:18,5
这个呢是关于只能够在堆上

314
0:15:18,5 --> 0:15:22,389
那如何定义只能够在栈上生成对象的类呢

315
0:15:22,389 --> 0:15:23,449
我们可以回答

316
0:15:23,449 --> 0:15:26,489
首先核心思路呢就是我们避免这个对象创建

317
0:15:26,489 --> 0:15:30,52
也就是呢通过删除new禁用new操作符

318
0:15:30,52 --> 0:15:33,89
包括数组对象的呃操作符

319
0:15:33,89 --> 0:15:35,73
还有呢就是placement new

320
0:15:35,73 --> 0:15:37,37
大家要说这个placement new呢

321
0:15:37,37 --> 0:15:39,93
是可能通过MALLOC来进行分配的

322
0:15:39,93 --> 0:15:42,52
然后呢通过placement new来进行构造

323
0:15:42,52 --> 0:15:47,44
所以呢我们还需要禁用placement new操作好

324
0:15:47,44 --> 0:15:48,28
通过这种方式呢

325
0:15:48,28 --> 0:15:51,519
我们就可以解决关于这道面试题

326
0:15:51,519 --> 0:15:53,159
大家如果需要本视频资料

327
0:15:53,159 --> 0:15:55,119
以及我们的代码的朋友呢

328
0:15:55,119 --> 0:15:56,399
可以一键三连加关注

329
0:15:56,399 --> 0:15:57,34
谢谢大家

