1
0:0:0,46 --> 0:0:1,18
哈喽大家好

2
0:0:1,18 --> 0:0:1,76
我是Mark

3
0:0:1,76 --> 0:0:3,28
今天跟大家分享一道面试题

4
0:0:3,28 --> 0:0:7,81
阿里智能信息息加一面CR时期的常用特性

5
0:0:7,81 --> 0:0:11,77
CR时期当中的智能指针以及它的使用场景

6
0:0:11,77 --> 0:0:14,88
我们可以参考cpp reference

7
0:0:14,88 --> 0:0:17,54
来了解西安时期的一些更新

8
0:0:17,54 --> 0:0:23,369
我们重点关注新的语言特性以及新的库特性

9
0:0:23,369 --> 0:0:27,469
那么大家可以看到在新的库的特性当中

10
0:0:27,469 --> 0:0:30,45
有内存管理里面提到了

11
0:0:30,45 --> 0:0:33,26
s std shell的PTR数组的支持

12
0:0:33,26 --> 0:0:36,52
我们问到C加的智能指针的使用场景

13
0:0:36,52 --> 0:0:40,1
那么大家可以看到在C加时期之前呢

14
0:0:40,1 --> 0:0:42,15
它是不支持这种数组的

15
0:0:42,15 --> 0:0:46,319
那么C加时期支持了这种数组的支持额

16
0:0:46,319 --> 0:0:49,259
因为之前呢我们要自定义的删除器

17
0:0:49,259 --> 0:0:52,239
那么C加时期呢他就不需要自定义删除器了

18
0:0:52,239 --> 0:0:55,19
就是之前关于数组这一部分

19
0:0:55,68 --> 0:0:56,72
然后大家可以看到

20
0:0:56,72 --> 0:1:0,45
在这里呢罗列了很多西加的时期的常用特性

21
0:1:0,45 --> 0:1:2,3
我们不可能全部都回答

22
0:1:2,3 --> 0:1:4,979
那么我们来列出常用的特性

23
0:1:4,979 --> 0:1:8,719
在这里呢我有详细的列出这么一些新的特性

24
0:1:8,719 --> 0:1:12,32
主要呢包括语言特性和库的新增组件

25
0:1:12,32 --> 0:1:15,8
围绕着这两个方面来跟大家进行讲解

26
0:1:15,8 --> 0:1:19,0
首先我们可以看到关于语言特性呢

27
0:1:19,0 --> 0:1:20,94
我们比较重要的点是

28
0:1:20,94 --> 0:1:22,81
比如说结构化绑定

29
0:1:22,81 --> 0:1:24,61
结构化绑定是什么意思呢

30
0:1:24,61 --> 0:1:28,289
就是将元组元组就是tube

31
0:1:28,289 --> 0:1:33,89
然后结构体数组的成员呢直接解包到变量当中

32
0:1:33,89 --> 0:1:35,24
具体的使用方式呢就是这样子的

33
0:1:35,24 --> 0:1:36,32
通过auto

34
0:1:36,32 --> 0:1:38,12
然后呢后面是expression

35
0:1:38,12 --> 0:1:40,44
expression里面呢就包含这些内容

36
0:1:40,44 --> 0:1:46,3
然后我们通过这种方式呢就直接拿到多返回值

37
0:1:46,3 --> 0:1:49,6
类似于这种多返回值的处理好

38
0:1:49,6 --> 0:1:50,22
它的主要应用场景呢

39
0:1:50,22 --> 0:1:52,87
就是简化多返回值的一个处理

40
0:1:52,87 --> 0:1:55,69
或者是去便利关联容器的时候

41
0:1:55,69 --> 0:1:56,55
Key value

42
0:1:56,55 --> 0:1:58,93
那么我们可以通过这种结构化绑定呢

43
0:1:58,93 --> 0:2:2,12
快速的得到他的key value好

44
0:2:2,12 --> 0:2:5,68
那么大家可以看到具体的额底层实现

45
0:2:5,68 --> 0:2:8,38
是编译器的一个行为

46
0:2:8,38 --> 0:2:10,6
它会自动生成代码

47
0:2:10,6 --> 0:2:12,6
将成员绑定在变量好

48
0:2:12,6 --> 0:2:14,47
我们通过具体的案例跟大家进行讲解

49
0:2:14,47 --> 0:2:17,21
比如说我们这里呢有一个map

50
0:2:17,21 --> 0:2:20,319
那么我们去往里面插入的时候

51
0:2:20,319 --> 0:2:21,91
它返回一个P

52
0:2:21,91 --> 0:2:24,27
那么我们可以通过结构化绑定呢

53
0:2:24,27 --> 0:2:27,1
直接拿到这个票里面的两个字段

54
0:2:27,1 --> 0:2:30,54
一个呢迭代器一个呢是是否成功好

55
0:2:30,54 --> 0:2:33,2
然后我们再可以看到关于结构体

56
0:2:33,2 --> 0:2:36,6
我们有X变量和Y变量

57
0:2:36,6 --> 0:2:40,28
那么我们可以直接通过auto这种结构化绑定呢

58
0:2:40,28 --> 0:2:42,42
直接取到X和Y的值

59
0:2:42,42 --> 0:2:45,56
那么我们就不像以前以往的方式呢

60
0:2:45,56 --> 0:2:47,66
呃P点X啊

61
0:2:47,66 --> 0:2:49,42
P点Y这种访问方式

62
0:2:49,42 --> 0:2:51,18
我们直接就可以拿到啊

63
0:2:51,18 --> 0:2:52,92
对应的这两个变量

64
0:2:52,92 --> 0:2:53,6
当然了

65
0:2:53,6 --> 0:2:56,11
我们是要按照这个顺序来的

66
0:2:56,23 --> 0:2:58,47
它的底层实现是什么呢

67
0:2:58,47 --> 0:2:59,99
底层实现就是我们的编译器

68
0:2:59,99 --> 0:3:1,59
它会生成这样的一个代码

69
0:3:1,59 --> 0:3:6,25
先auto一个临时的变量去对应着这个P

70
0:3:6,25 --> 0:3:10,96
然后呢把他们去赋值给X和Y好

71
0:3:10,96 --> 0:3:12,84
他其实本质上的编译器

72
0:3:12,84 --> 0:3:15,24
帮我们生成了一个临时对象好

73
0:3:15,24 --> 0:3:16,4
那么还有一个呢就是pal

74
0:3:18,23 --> 0:3:21,27
pl的本质呢就是因为我们插入的时候

75
0:3:21,27 --> 0:3:23,17
它会返回一个s d d pl

76
0:3:23,17 --> 0:3:26,11
那么呢我们可以直接通过这种结构化绑定呢

77
0:3:26,11 --> 0:3:28,639
就拿到这pl里面的两个字段

78
0:3:28,639 --> 0:3:32,31
first和second数组也是如此

79
0:3:32,31 --> 0:3:34,75
数组我们也可以依次的去获取

80
0:3:34,75 --> 0:3:38,8
通过这种结构化绑定呢获取到对应的值

81
0:3:38,8 --> 0:3:41,32
结构化绑定我们需要注意的事项是

82
0:3:41,84 --> 0:3:46,35
顺序必须按照结构体声明的顺序

83
0:3:46,35 --> 0:3:49,3
原组成员的声明的顺序呢一致

84
0:3:49,3 --> 0:3:53,709
而不能够像其他语言可以调整顺序是不可以的

85
0:3:53,709 --> 0:3:55,449
而且呢必须解包

86
0:3:55,449 --> 0:3:58,45
所有的成员不能够跳过某些成员

87
0:3:58,45 --> 0:4:0,53
像LUA或一些动态语言呢

88
0:4:0,53 --> 0:4:1,33
它可以跳过

89
0:4:1,33 --> 0:4:3,67
在这里呢是不允许跳过的

90
0:4:3,99 --> 0:4:6,47
仅支持绑定public成员

91
0:4:6,47 --> 0:4:8,21
也就是如果你是类的话

92
0:4:8,21 --> 0:4:10,45
像private里面它就是不允许的

93
0:4:10,45 --> 0:4:11,49
那么在面试的时候

94
0:4:11,49 --> 0:4:13,21
我们肯定不会说这么多

95
0:4:13,21 --> 0:4:15,32
面试当中我们可以回答

96
0:4:15,32 --> 0:4:16,24
结构化绑定

97
0:4:16,24 --> 0:4:19,44
主要解决了一个多返回值的一个处理获利

98
0:4:19,44 --> 0:4:22,4
或者是用于处理便利的关联容器

99
0:4:22,4 --> 0:4:24,909
好通过这种方式回答就可以了

100
0:4:25,309 --> 0:4:27,669
然后我们再来看一下另外一个呢

101
0:4:27,669 --> 0:4:30,62
就是if和switch语句当中的初始化器

102
0:4:30,62 --> 0:4:34,1
或者我们也可以说带初始化的条件变量

103
0:4:34,1 --> 0:4:37,4
这种呢是比较口述的方式呢

104
0:4:37,4 --> 0:4:38,64
呃比较方便

105
0:4:38,64 --> 0:4:42,54
它的作用是在条件语句或者是switch语句当中

106
0:4:42,54 --> 0:4:43,87
声明变量

107
0:4:43,87 --> 0:4:46,47
通过这种方式呢是限制作用域啊

108
0:4:46,47 --> 0:4:48,32
这个呢是它的核心作用

109
0:4:48,32 --> 0:4:49,48
限制作用域

110
0:4:49,48 --> 0:4:51,36
那么大家要知道这个限制作用域

111
0:4:51,36 --> 0:4:52,44
它的规则是什么

112
0:4:52,44 --> 0:4:54,99
它的规则呢就是比如说if语句

113
0:4:54,99 --> 0:4:58,38
那么它的这个作用域的范围是多少呢

114
0:4:58,38 --> 0:5:3,24
它的范围是在if代码块和else代码块都是可见的

115
0:5:3,24 --> 0:5:6,43
虽然我们是在if代码块当中去呃

116
0:5:6,43 --> 0:5:7,67
声明的这个条件变量

117
0:5:7,67 --> 0:5:12,84
但是呢在else当中仍然有它的作用域是可见的

118
0:5:12,84 --> 0:5:14,48
另外呢就是switch语句

119
0:5:14,48 --> 0:5:17,28
它是在整个switch dimm当中呢都是可见的

120
0:5:17,28 --> 0:5:20,159
包括所有的case分支都是可以看到的

121
0:5:20,159 --> 0:5:22,19
好我们看一下应用场景

122
0:5:22,19 --> 0:5:27,64
比如说我们可以在前面进行一个初始化

123
0:5:27,64 --> 0:5:30,56
然后呢后面是我们的条件判断

124
0:5:30,56 --> 0:5:31,56
那么大家可以看到

125
0:5:31,56 --> 0:5:35,73
那么这个it的作用域呢就是在这个if里面好

126
0:5:35,73 --> 0:5:37,73
那么还有一个用的比较多的

127
0:5:37,73 --> 0:5:39,83
就是我们平常在使用的时候

128
0:5:39,83 --> 0:5:41,13
在多线程编程当中

129
0:5:41,13 --> 0:5:42,25
比如说我们用一个锁

130
0:5:42,25 --> 0:5:44,26
我希望这个互斥锁

131
0:5:44,26 --> 0:5:48,7
它的作用域范围是在这个if代码块里面

132
0:5:48,7 --> 0:5:51,59
那么我们就可以使用这种带初始化的条件语句

133
0:5:51,59 --> 0:5:52,75
先初始化

134
0:5:52,75 --> 0:5:54,67
然后进行条件判断

135
0:5:54,67 --> 0:5:57,5
那么初始化的这个lock

136
0:5:57,5 --> 0:6:1,8
它会在这里进行调用构造函数

137
0:6:1,8 --> 0:6:4,18
也就构造函数当中会掉他的lock加锁

138
0:6:4,18 --> 0:6:9,21
然后走出生命周期的时候调unlock释放锁

139
0:6:9,47 --> 0:6:14,87
那么他的回答在面试当中回答怎么说呢

140
0:6:14,87 --> 0:6:16,79
呃第一个是结构化绑定

141
0:6:16,79 --> 0:6:19,19
第二个呢是带初始化的条件语句

142
0:6:19,19 --> 0:6:23,26
那么呢我们主要的作用是限制我们的作用域

143
0:6:23,26 --> 0:6:25,92
初始化的内容的作用域啊

144
0:6:25,92 --> 0:6:27,799
主要利用了这样的一个特性

145
0:6:27,799 --> 0:6:30,899
那么接下来第三个是内联变量

146
0:6:30,899 --> 0:6:31,679
内联变量呢

147
0:6:31,679 --> 0:6:34,93
也是我们工作当中用的比较多的一种方式

148
0:6:34,93 --> 0:6:38,67
它的作用是允许头文件当中定义初始化

149
0:6:38,67 --> 0:6:41,49
全局变量或者是静态成员变量

150
0:6:41,49 --> 0:6:43,14
大家注意这两跟内容

151
0:6:43,14 --> 0:6:44,24
这是我们的对象

152
0:6:44,24 --> 0:6:45,36
一个呢是全局变量

153
0:6:45,36 --> 0:6:47,18
另外一个呢是静态成员变量

154
0:6:47,18 --> 0:6:49,54
静态成员变量马上想到的是什么呢

155
0:6:49,54 --> 0:6:51,82
就是我们面试当中经常会问到的

156
0:6:51,82 --> 0:6:53,18
这种单例的实现

157
0:6:53,18 --> 0:6:56,86
那么等会会跟大家介绍它的底层原理

158
0:6:56,86 --> 0:6:58,98
是链接器的一个工作

159
0:6:58,98 --> 0:7:1,3
像前面的结构化绑定呢

160
0:7:1,3 --> 0:7:2,58
它是编译器的行为

161
0:7:2,58 --> 0:7:4,26
这个呢是链接器的行为

162
0:7:4,26 --> 0:7:9,409
它会把所有的编译单元当中的同同名内联变量

163
0:7:9,409 --> 0:7:12,149
会被链接器合并成一个实体

164
0:7:12,149 --> 0:7:15,0
这个呢是它的主要的底层原理好

165
0:7:15,0 --> 0:7:17,42
那么我们可以给大家看几个案例

166
0:7:17,42 --> 0:7:21,44
第一个呢是不使用内联变量的单例模式啊

167
0:7:21,44 --> 0:7:22,56
那么我们在这里呢

168
0:7:22,56 --> 0:7:25,0
声明定义了一个静态成员变量

169
0:7:25,0 --> 0:7:28,34
那么我们需要在内外呢去进行一个初始化

170
0:7:28,34 --> 0:7:31,71
这个呢是我们CR时期之前都得这么做的

171
0:7:32,71 --> 0:7:34,27
那么西R时期之后呢

172
0:7:34,27 --> 0:7:36,3
我们就可以不写呃

173
0:7:36,3 --> 0:7:38,32
在内外去进行初始化了

174
0:7:38,32 --> 0:7:41,69
好我们可以在前面加上一个关键字in line

175
0:7:41,69 --> 0:7:44,29
然后呢直接在这里呢进行初始化

176
0:7:44,29 --> 0:7:47,17
也就是内联静态成员变量的一个初始化

177
0:7:47,17 --> 0:7:49,83
那么我们就不需要在内外呢去做了

178
0:7:49,83 --> 0:7:50,71
做这件事情了

179
0:7:50,71 --> 0:7:52,87
这个呢是针对静态成员变量

180
0:7:52,87 --> 0:7:57,88
那么另外一个呢是静针对我们的全局变量好

181
0:7:57,88 --> 0:8:2,31
那么全局变量呢我们需要在头文件当中声明

182
0:8:2,31 --> 0:8:5,49
然后呢在一个原文件当中呢去进行一个定义

183
0:8:5,49 --> 0:8:7,4
通过extend

184
0:8:7,4 --> 0:8:10,79
然后呢去进行一个引用好

185
0:8:10,79 --> 0:8:14,679
那么大家需要注意的点是它的注意事项

186
0:8:14,679 --> 0:8:19,119
内联内联变量呢它必须在定义时显示的

187
0:8:19,119 --> 0:8:21,55
要进行初始化呃

188
0:8:21,55 --> 0:8:22,51
inline呢

189
0:8:22,51 --> 0:8:27,22
只能用于全局变量和类的静态成员变量好

190
0:8:27,22 --> 0:8:29,62
大家一定要明确他的对象

191
0:8:29,62 --> 0:8:32,72
那么我们在面试的时候回答内容变量呢

192
0:8:32,72 --> 0:8:38,59
就是主要我们可以从允许头文件当中

193
0:8:38,59 --> 0:8:43,19
定义并初始化全局变量和静态成员变量

194
0:8:43,19 --> 0:8:45,75
避免重复定义好

195
0:8:45,75 --> 0:8:47,85
这个呢是关于内联变量

196
0:8:47,85 --> 0:8:49,17
我们该怎么回答

197
0:8:49,17 --> 0:8:51,73
然后第二个特性就是一个是语言特性

198
0:8:51,73 --> 0:8:53,97
另外一个呢是标准库新增组件

199
0:8:53,97 --> 0:8:57,22
那这里呢我列举出了在实际开发当中

200
0:8:57,22 --> 0:8:58,3
用的最多的两个

201
0:8:58,3 --> 0:8:59,74
一个呢是option

202
0:8:59,74 --> 0:9:3,8
option呢我们首先要理解它为什么会有这种option

203
0:9:3,8 --> 0:9:5,98
option没有option之前

204
0:9:5,98 --> 0:9:7,56
我们是怎么做的呢

205
0:9:7,56 --> 0:9:10,64
啊我们以前可能用特殊值标记

206
0:9:10,64 --> 0:9:15,63
比如说空指针一和空字符串代表着它不存在

207
0:9:15,63 --> 0:9:21,23
那么或者呢像在通过返回值和布尔状态

208
0:9:21,23 --> 0:9:24,39
通常比如说我们用pop pop呢

209
0:9:24,39 --> 0:9:29,31
在它的返回值是不不就是true或者是false

210
0:9:29,31 --> 0:9:31,53
这是pop成功了还是失败了

211
0:9:31,53 --> 0:9:32,49
成功了呢

212
0:9:32,49 --> 0:9:35,36
我们就通过这种引用值好

213
0:9:35,36 --> 0:9:38,32
引用值去获取我们的内容好

214
0:9:38,32 --> 0:9:41,19
那么这种呢是通过这种方式

215
0:9:41,19 --> 0:9:44,65
那么我们其实呢也可以用option来解决这种问题

216
0:9:45,73 --> 0:9:49,375
那option它是什么样的一个语义呢

217
0:9:50,29 --> 0:9:54,359
它表示着可能存在的值

218
0:9:54,359 --> 0:9:55,999
可能存在的值

219
0:9:55,999 --> 0:10:0,21
也就是它是一个可能包含某一个类型

220
0:10:0,21 --> 0:10:2,39
或者是无值的容器啊

221
0:10:2,39 --> 0:10:4,569
我们一定要理解这一句话

222
0:10:4,969 --> 0:10:7,89
它的作用就是刚刚跟大家说了

223
0:10:7,89 --> 0:10:8,489
然后就是注意事项

224
0:10:8,489 --> 0:10:11,349
禁止未检查的访问

225
0:10:11,349 --> 0:10:13,969
关于这个option在使用的过程当中呢

226
0:10:13,969 --> 0:10:16,56
你你不太确定它

227
0:10:16,56 --> 0:10:18,72
而如果它可能是一个无职的

228
0:10:18,72 --> 0:10:19,58
你直接使用它

229
0:10:19,58 --> 0:10:21,24
它可能会抛出异常

230
0:10:21,24 --> 0:10:22,82
导致未定义的行为

231
0:10:22,82 --> 0:10:25,45
所以呢我们在option的时候

232
0:10:25,45 --> 0:10:27,27
一定要检查它是不是存在

233
0:10:27,27 --> 0:10:28,41
那是不是有

234
0:10:28,41 --> 0:10:29,1
有的话

235
0:10:29,1 --> 0:10:30,13
我们再访问好

236
0:10:30,13 --> 0:10:33,71
等下我们看一下应用场景函数的可选

237
0:10:33,71 --> 0:10:35,57
返回值和配置项解析

238
0:10:35,57 --> 0:10:36,53
这是它的应用场景

239
0:10:36,53 --> 0:10:37,8
我们依次来看

240
0:10:37,8 --> 0:10:40,8
比如说我们要查找用户

241
0:10:40,8 --> 0:10:42,4
但是呢这个用户可能不存在

242
0:10:42,4 --> 0:10:47,51
所以呢我们用sd d option optional user

243
0:10:47,51 --> 0:10:49,69
然后大家可以看到存在的话呢

244
0:10:49,69 --> 0:10:51,3
就返回这个user

245
0:10:51,3 --> 0:10:52,5
不存在的话呢

246
0:10:52,5 --> 0:10:54,67
我们就用NNOPT好

247
0:10:54,67 --> 0:10:59,64
那么我们可以看到先需要去放的

248
0:10:59,64 --> 0:11:3,51
那么这里呢实际上本质上会做一个检查啊

249
0:11:3,51 --> 0:11:5,27
如果它存在的话

250
0:11:5,27 --> 0:11:6,91
就是调这个不存在的话

251
0:11:6,91 --> 0:11:8,429
就是调这一个好

252
0:11:8,429 --> 0:11:12,109
所以呢我们大家一定要注意它的一个注意事项

253
0:11:12,109 --> 0:11:16,16
一定要检查我们的这个optional

254
0:11:16,16 --> 0:11:17,78
再去使用它好

255
0:11:17,78 --> 0:11:20,4
这个呢就是先通过if去检查它

256
0:11:20,4 --> 0:11:21,56
然后再去使用它

257
0:11:21,56 --> 0:11:23,6
如果你直接使用它

258
0:11:23,6 --> 0:11:25,86
那么就可能会造成未定义的行为

259
0:11:25,86 --> 0:11:28,789
他会抛异常的好

260
0:11:28,789 --> 0:11:30,949
另外一个我们可以看到呃

261
0:11:30,949 --> 0:11:33,54
我们在解析配配配置项的时候

262
0:11:33,54 --> 0:11:35,1
那么这个CONFIG当中呢

263
0:11:35,1 --> 0:11:37,3
可能没有这个port这样的一个字段

264
0:11:37,3 --> 0:11:39,949
那么呢我们就会返回NNOPD好

265
0:11:39,949 --> 0:11:42,149
大家看到我们也可以使用默认值

266
0:11:42,149 --> 0:11:42,929
我们刚刚说了

267
0:11:42,929 --> 0:11:43,989
要检查对不对

268
0:11:43,989 --> 0:11:45,389
还有提供一种语法

269
0:11:45,389 --> 0:11:47,2
就是value or

270
0:11:47,2 --> 0:11:49,26
也就是说如果它不存在的话

271
0:11:49,26 --> 0:11:52,41
那么我们就使用默认值8080

272
0:11:52,73 --> 0:11:55,69
这个呢是关于optional的一个用法

273
0:11:55,69 --> 0:11:57,31
那面试当中我们怎么回答呢

274
0:11:57,31 --> 0:11:58,59
就是optional

275
0:11:58,59 --> 0:12:4,939
它是表示着一个可能包含某值或者是无值的

276
0:12:4,939 --> 0:12:7,499
这样的一个容器啊

277
0:12:7,499 --> 0:12:9,999
它的使用需要注意

278
0:12:9,999 --> 0:12:13,979
不能直接访问空的option对象

279
0:12:14,34 --> 0:12:14,74
好

280
0:12:14,74 --> 0:12:15,8
这样子就可以了

281
0:12:15,8 --> 0:12:19,5
然后接着我们再来看一下string view

282
0:12:19,5 --> 0:12:20,99
string view呢是用的比较多的

283
0:12:20,99 --> 0:12:24,99
实际加实习的一种重要的一个特性

284
0:12:24,99 --> 0:12:27,75
它是一个轻量级的非拥有好

285
0:12:27,75 --> 0:12:28,63
String view

286
0:12:28,63 --> 0:12:29,95
第一个需要理解的

287
0:12:29,95 --> 0:12:33,28
它是一个非拥有字符串视图类好

288
0:12:33,28 --> 0:12:34,16
这是第二个

289
0:12:34,16 --> 0:12:35,28
第一个是非拥有

290
0:12:35,28 --> 0:12:36,6
第二个呢是视图类

291
0:12:36,6 --> 0:12:38,4
视图类呢是只读的

292
0:12:38,4 --> 0:12:39,44
不能够修改

293
0:12:39,44 --> 0:12:41,89
只能够去读取

294
0:12:41,89 --> 0:12:46,35
非拥有呢就是他不真正的拥有资源好

295
0:12:46,35 --> 0:12:48,47
那么我们可以看到

296
0:12:49,5 --> 0:12:52,3
呃为什么大家看到非拥有什么意思呢

297
0:12:52,3 --> 0:12:54,78
因为我们只包含它的指针和长程度

298
0:12:54,78 --> 0:12:59,26
不包含这个指针所指向的这个资源是不包含的

299
0:12:59,26 --> 0:13:3,51
它主要的作用是避免拷贝好

300
0:13:3,51 --> 0:13:5,69
但是大家需要注意它的一个风险

301
0:13:5,69 --> 0:13:8,46
第一个呢就是因为我不非拥有

302
0:13:8,46 --> 0:13:11,54
那么如果拥有的那个对象被销毁了

303
0:13:11,54 --> 0:13:14,2
那么我们可能会指向一个无效的内存

304
0:13:14,2 --> 0:13:17,64
那么就会造成悬挂引用的风险好

305
0:13:17,64 --> 0:13:19,8
另外一个就是只读

306
0:13:19,8 --> 0:13:21,59
不能够去修改底层的数据结构

307
0:13:21,59 --> 0:13:23,93
那么我们平常使用的时候呢

308
0:13:23,93 --> 0:13:26,39
比如说解析器日志好

309
0:13:26,39 --> 0:13:29,119
高频字符串处理的场景好

310
0:13:29,119 --> 0:13:31,66
大家可以看到这样的一个案例呃

311
0:13:31,66 --> 0:13:34,74
大家可能会觉得我为什么要使用string view呢

312
0:13:34,74 --> 0:13:37,72
我能不能够用constant s std string

313
0:13:37,72 --> 0:13:40,15
用这种引用的方式呢

314
0:13:40,39 --> 0:13:44,65
用引用的方式它能否避免拷贝呢

315
0:13:44,65 --> 0:13:46,55
好可以避免拷拷贝

316
0:13:46,55 --> 0:13:47,57
大家应该都知道

317
0:13:47,57 --> 0:13:52,27
但是我们这里可能会出现影视构造的问题

318
0:13:52,27 --> 0:13:55,6
就是为什么我要a string view啊

319
0:13:55,6 --> 0:13:56,74
为什么不用这种引用的方式

320
0:13:56,74 --> 0:13:58,18
因为这种引用的方式呢

321
0:13:58,18 --> 0:14:0,2
它可能会出现影视构造的问题

322
0:14:0,2 --> 0:14:4,659
比如说你用一个字面值去初始去调这个process

323
0:14:4,659 --> 0:14:5,659
string的时候

324
0:14:5,659 --> 0:14:6,959
他也能够调成功

325
0:14:6,959 --> 0:14:9,259
因为他先会去构造这样的一个对象

326
0:14:9,259 --> 0:14:12,679
然后再是引用传递进去好

327
0:14:12,679 --> 0:14:13,519
那么大家可以看到

328
0:14:13,519 --> 0:14:16,15
如果我没有string view的话好

329
0:14:16,15 --> 0:14:18,67
那么就不会去出现影视构造的问题

330
0:14:18,67 --> 0:14:20,27
我压根就不会出现构造

331
0:14:20,27 --> 0:14:23,23
也就是呢这种引用的传递的方式呢

332
0:14:23,23 --> 0:14:26,64
仍然没法避免拷贝的问题

333
0:14:28,6 --> 0:14:29,82
接下来我们看具体的应用场景

334
0:14:29,82 --> 0:14:32,6
比如说解析HTP请求头

335
0:14:32,6 --> 0:14:34,56
那么我们就会用这种string view

336
0:14:34,56 --> 0:14:37,8
因为呢我们通常不会去修改它

337
0:14:37,8 --> 0:14:40,74
我们只会看它是否完整

338
0:14:40,74 --> 0:14:43,6
解析这个数据是否完整啊

339
0:14:43,6 --> 0:14:46,329
并且呢我要知道这个hod里面的内容

340
0:14:46,329 --> 0:14:47,649
另外一个就是

341
0:14:47,649 --> 0:14:50,689
比如说我们想要把这个字符串进行分割好

342
0:14:50,689 --> 0:14:52,359
那么我们也可以用spring view

343
0:14:52,359 --> 0:14:56,599
那么这样子呢就不会出现很多的小的内存碎片

344
0:14:56,599 --> 0:15:0,56
就是好的string小的string的小对象

345
0:15:1,24 --> 0:15:3,76
关于CR时期常用特性呢

346
0:15:3,76 --> 0:15:5,24
就跟大家分享到这

347
0:15:5,24 --> 0:15:7,36
如果大家需要本视频资料的朋友呢

348
0:15:7,36 --> 0:15:8,72
可以一键三连加关注

349
0:15:8,72 --> 0:15:9,68
谢谢大家

