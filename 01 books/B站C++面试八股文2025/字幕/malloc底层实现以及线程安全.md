1
0:0:0,36 --> 0:0:0,76
Hello

2
0:0:0,76 --> 0:0:0,96
大家好

3
0:0:0,96 --> 0:0:1,56
我是马克

4
0:0:1,56 --> 0:0:3,22
今天跟大家分享一道面试题

5
0:0:3,22 --> 0:0:7,41
腾讯后台C加游戏开发e ma my log的底层

6
0:0:7,41 --> 0:0:9,11
my loft的线程安全

7
0:0:9,11 --> 0:0:11,67
如何与系统调用动态交互

8
0:0:11,67 --> 0:0:15,489
my lock的内部加锁的力度等等

9
0:0:15,489 --> 0:0:18,709
本视频的参考资料来源于这篇博客

10
0:0:18,709 --> 0:0:20,94
大家可以关注一下

11
0:0:20,94 --> 0:0:24,68
同时呢我们是讲解的GLAB7my lock

12
0:0:24,68 --> 0:0:28,6
然后呢我们来讲解一下MALLOC的底层实现

13
0:0:28,6 --> 0:0:31,36
我们可以从两个维度来进行回复

14
0:0:31,36 --> 0:0:32,58
第一个

15
0:0:32,58 --> 0:0:36,68
核心数据结构和核心数据结构之间的关系

16
0:0:36,68 --> 0:0:38,54
第二个是行为

17
0:0:38,54 --> 0:0:40,18
也就是分配与释放

18
0:0:40,18 --> 0:0:42,46
那么大家需要明确的一点是

19
0:0:42,46 --> 0:0:45,78
MALLOC当在进行大内存分配的时候呢

20
0:0:45,78 --> 0:0:48,529
我们是采用main map进行分配的

21
0:0:48,529 --> 0:0:50,409
通过MMAP进行释放

22
0:0:50,409 --> 0:0:53,48
这里的大内存是指大于128KB

23
0:0:53,48 --> 0:0:56,2
如果是小于一百二十二八KB的时候呢

24
0:0:56,2 --> 0:0:59,48
我们需要了解my logo的核心数据结构

25
0:0:59,48 --> 0:1:1,57
以及它的分配与释放

26
0:1:1,57 --> 0:1:4,37
那么接下来我们来看一下核心数据结构

27
0:1:4,37 --> 0:1:6,23
这里有arena

28
0:1:6,23 --> 0:1:7,79
Trunk beans

29
0:1:7,79 --> 0:1:12,54
arena呢它是线程级的内存管理的容器

30
0:1:12,54 --> 0:1:15,56
维持管理着多个trunk和beans

31
0:1:15,56 --> 0:1:21,8
这里的线程级是指我们当小于线程限制的时候

32
0:1:21,8 --> 0:1:24,289
每一个线程都会对应着一个arena

33
0:1:24,289 --> 0:1:27,249
那么如果大于线程限制的话

34
0:1:27,249 --> 0:1:30,929
那么呢就可能出现arena之间的一个竞争的问题

35
0:1:30,929 --> 0:1:33,785
就是线程竞争arena的问题

36
0:1:34,95 --> 0:1:37,53
trunk是内存分配的基本单位

37
0:1:37,53 --> 0:1:39,47
其中包括两个重要的部分

38
0:1:39,47 --> 0:1:41,5
一个呢是已分配块

39
0:1:41,5 --> 0:1:42,62
另外一个呢是空闲块

40
0:1:42,62 --> 0:1:45,94
已分配块就是用于存储用户数据控型块

41
0:1:45,94 --> 0:1:48,509
用于存储已经释放的数据

42
0:1:48,509 --> 0:1:51,389
那么这个已释放的数据也就是空闲块

43
0:1:51,389 --> 0:1:52,609
如何来进行管理呢

44
0:1:52,609 --> 0:1:54,929
它是通过beans来进行管理的

45
0:1:54,929 --> 0:1:58,53
它beans是用来复用空闲块

46
0:1:58,53 --> 0:2:1,39
然后目的是减少系统调用

47
0:2:1,39 --> 0:2:5,85
这个系统调用包括BRK以及MEMMAP

48
0:2:6,5 --> 0:2:7,87
我们刚刚跟大家说的是

49
0:2:7,87 --> 0:2:11,9
这个核心数据结构和这里所说的分配与释放的

50
0:2:11,9 --> 0:2:12,21
都是对应着小内存

51
0:2:12,21 --> 0:2:14,59
也就是小于188KB的

52
0:2:14,59 --> 0:2:17,6
接下来我们来看一下分配与释放

53
0:2:17,8 --> 0:2:19,2
如何进行分配呢

54
0:2:19,2 --> 0:2:23,34
我们优先先查找当前线程的arena

55
0:2:23,34 --> 0:2:26,82
那么接下来arena呢它是管理的多个beans的

56
0:2:26,82 --> 0:2:29,1
那么我们是从以分配

57
0:2:29,1 --> 0:2:32,46
就是已经释放的这些空间当中呢去进行分配

58
0:2:32,46 --> 0:2:33,9
那么我们来看一下

59
0:2:33,9 --> 0:2:35,94
先会检查fast bean

60
0:2:35,94 --> 0:2:38,58
然后再去检查on sorted bean

61
0:2:38,58 --> 0:2:41,56
接着是smooth bean以及lat bean

62
0:2:41,56 --> 0:2:44,68
那么它们之间的大小关系是什么呢

63
0:2:44,68 --> 0:2:48,17
fast bin是16~80字节的小内存块

64
0:2:48,17 --> 0:2:50,45
unsorted bean呢就是我们刚刚存储

65
0:2:50,45 --> 0:2:53,53
刚刚释放的small或者是large块

66
0:2:53,53 --> 0:2:55,93
它是用于临时存储

67
0:2:55,93 --> 0:3:0,9
接着呢就是small beans小于一五百一十二个字节

68
0:3:0,9 --> 0:3:1,37
大于80个字节

69
0:3:1,37 --> 0:3:4,36
luck beans大于等于512个字节

70
0:3:4,36 --> 0:3:9,78
那么它们分别是small bin是双向链表啊

71
0:3:9,78 --> 0:3:11,0
First in first out

72
0:3:11,0 --> 0:3:11,92
先进先出

73
0:3:11,92 --> 0:3:14,28
类似队列合并相邻块

74
0:3:14,28 --> 0:3:18,4
也就是small bean和LABEAN的都会进行合并相邻块

75
0:3:18,68 --> 0:3:20,32
另外一个就是top chunk

76
0:3:20,32 --> 0:3:21,76
top chunk的是arena

77
0:3:21,76 --> 0:3:24,56
也就是县城所属的这个arena的顶部

78
0:3:24,56 --> 0:3:26,15
未分配的备用块

79
0:3:26,15 --> 0:3:28,72
病死呢无法嗯

80
0:3:28,72 --> 0:3:29,6
没有适合的时候

81
0:3:29,6 --> 0:3:31,44
就是我们在上面的bans里面

82
0:3:31,44 --> 0:3:33,28
没有找到对应的内存的时候

83
0:3:33,28 --> 0:3:35,4
也就是分内存分配的时候没有找到的话

84
0:3:35,4 --> 0:3:37,85
那么我们就会从top trunk里面去找

85
0:3:37,85 --> 0:3:39,77
如果top trunk不足的话

86
0:3:39,77 --> 0:3:43,1
那么我们可能会需要进行扩展堆区了

87
0:3:43,64 --> 0:3:46,56
好那么我们了解了这个具体的分配过程

88
0:3:46,56 --> 0:3:48,22
先去找arena

89
0:3:48,22 --> 0:3:50,22
然后找fast stin

90
0:3:50,22 --> 0:3:51,29
找到合适

91
0:3:51,29 --> 0:3:52,65
是不是小内存

92
0:3:52,65 --> 0:3:55,29
如果是小内存在fast bean里面找到

93
0:3:55,29 --> 0:3:57,11
那么我们就直接返回了啊

94
0:3:57,11 --> 0:3:59,4
如果没有的话

95
0:3:59,4 --> 0:4:1,22
那么呢我们就去unsorted bean

96
0:4:1,22 --> 0:4:3,96
也就是之前呃刚刚释放的

97
0:4:3,96 --> 0:4:6,95
我们优先从里面呢去找合适的

98
0:4:6,95 --> 0:4:8,69
然后再去small beans

99
0:4:8,69 --> 0:4:10,37
如果是小于128呃

100
0:4:10,37 --> 0:4:11,87
512字节的快

101
0:4:11,87 --> 0:4:14,11
那么我们就从small beans里面去找

102
0:4:14,11 --> 0:4:16,68
如果大于等于512

103
0:4:18,8 --> 0:4:21,649
接着呢还不满足的话

104
0:4:21,649 --> 0:4:23,949
那么我们就直接去top trunk

105
0:4:23,949 --> 0:4:24,729
Top trunk

106
0:4:24,729 --> 0:4:25,629
如果不足的话

107
0:4:25,629 --> 0:4:28,32
那么我们的这个时候分情况讨论了

108
0:4:28,32 --> 0:4:29,62
如果是主线程的话

109
0:4:29,62 --> 0:4:33,13
我们通过BRK进行扩展堆断

110
0:4:33,13 --> 0:4:35,51
然后呢如果是子线程的话

111
0:4:35,51 --> 0:4:38,89
子线程就是peace thread grate来进行创建的

112
0:4:38,89 --> 0:4:42,43
如果在这个子线程当中去分配空间的话

113
0:4:42,43 --> 0:4:43,53
动态分配空间的话

114
0:4:43,53 --> 0:4:47,7
它是通过MAMMAP来分配新的堆段

115
0:4:47,7 --> 0:4:49,49
也就是hip大家需要注意的是

116
0:4:49,49 --> 0:4:54,17
这个BRK它是调整的读一段

117
0:4:54,17 --> 0:4:57,29
然后我们的main map它调整的

118
0:4:57,29 --> 0:5:1,63
他是从文件映射区去进行分配空间的

119
0:5:1,63 --> 0:5:3,5
它们的一个差异

120
0:5:3,5 --> 0:5:4,97
那么我们顺便介绍一下

121
0:5:4,97 --> 0:5:7,95
32位模式下面的虚拟内存空间的布局

122
0:5:7,95 --> 0:5:10,73
上面呢是我们的内核空间

123
0:5:10,73 --> 0:5:13,43
然后就是占站区

124
0:5:13,43 --> 0:5:14,95
文件映射区

125
0:5:14,95 --> 0:5:18,85
堆区BSS区以及数据区

126
0:5:18,85 --> 0:5:20,659
还有就是代码区

127
0:5:20,659 --> 0:5:23,219
那么它们分别对应着的作用呢

128
0:5:23,219 --> 0:5:25,999
就是站是我们系统自动管理的

129
0:5:25,999 --> 0:5:28,64
然后就是文件映射区

130
0:5:28,64 --> 0:5:30,4
像我们的动态库

131
0:5:30,4 --> 0:5:33,71
以及我们在这里跟大家介绍的动态分配

132
0:5:33,71 --> 0:5:36,79
大于128KB字节的数据分配

133
0:5:36,79 --> 0:5:38,8
也是来源于这里

134
0:5:38,8 --> 0:5:42,36
另外一个呢就是我们通过小于188

135
0:5:42,36 --> 0:5:44,8
通过BRK分配的

136
0:5:44,8 --> 0:5:46,11
就是在我们的堆区好

137
0:5:46,11 --> 0:5:49,51
那么这个呢是静态全局的未初始化

138
0:5:49,51 --> 0:5:51,57
然后已经初始化的

139
0:5:51,57 --> 0:5:54,25
还有就是已经初始化的全局变量

140
0:5:54,25 --> 0:5:57,53
或者是我们的静态变量

141
0:5:57,53 --> 0:5:59,57
这个呢就是我们的代码所在的位置

142
0:6:0,65 --> 0:6:2,57
也就是具体的函数等等

143
0:6:2,57 --> 0:6:3,7
好

144
0:6:3,7 --> 0:6:5,4
然后我们回到这里

145
0:6:5,72 --> 0:6:9,32
接下来我们来说一下释放释放呢是小内存

146
0:6:9,32 --> 0:6:12,82
直接加入fast be其他内存

147
0:6:12,82 --> 0:6:14,22
其他内存是指什么意思呢

148
0:6:14,22 --> 0:6:15,74
就是我们在释放内存的时候呢

149
0:6:15,74 --> 0:6:17,5
先检查这个具体空间的大小

150
0:6:17,5 --> 0:6:18,9
如果在16~80个字节

151
0:6:18,9 --> 0:6:21,54
我们就直接从放到fast d里面

152
0:6:21,54 --> 0:6:22,84
如果大于80个字节

153
0:6:22,84 --> 0:6:26,4
那么接下来就是从下面进行额存储了

154
0:6:26,4 --> 0:6:29,99
那么我们会存储到这个unsorted bean

155
0:6:29,99 --> 0:6:32,87
那存储到UN缩ted bean的前面的行为是什么呢

156
0:6:32,87 --> 0:6:35,22
先需要检查相邻块是否空闲

157
0:6:35,22 --> 0:6:38,6
我们合并之后再加入到unsorted bean

158
0:6:38,6 --> 0:6:40,98
那么在这里需要大家注意这个其他内存呢

159
0:6:40,98 --> 0:6:43,36
不管是small chunk还是like trunk

160
0:6:43,36 --> 0:6:45,66
这个small trunk呢就是小于512

161
0:6:45,66 --> 0:6:46,54
大于80

162
0:6:46,54 --> 0:6:47,38
large trunk呢

163
0:6:47,38 --> 0:6:49,62
就是大于等于512字节的快

164
0:6:49,62 --> 0:6:53,16
那么呢我们都是先放在unsorted bean

165
0:6:53,16 --> 0:6:54,59
那很多朋友会有疑问

166
0:6:54,59 --> 0:6:57,15
为什么small trunk不会放在small bean

167
0:6:57,15 --> 0:7:0,32
然后large chunk为什么不放在LUBEAN里面呢

168
0:7:0,32 --> 0:7:1,6
好那么大家需要注意

169
0:7:1,6 --> 0:7:5,68
是在未来我们分配的时候

170
0:7:5,68 --> 0:7:8,58
检索到small bean或者是垃圾bean失败之后

171
0:7:8,58 --> 0:7:11,3
那么未来我们会从UNSOBEAN里面

172
0:7:11,3 --> 0:7:15,15
把trunks去进行转移到small ban或者是垃圾bean

173
0:7:15,15 --> 0:7:17,48
也就是它转移的方式呢是在分配的时候

174
0:7:17,48 --> 0:7:18,42
分配失败了

175
0:7:18,42 --> 0:7:19,7
在smoban like bean

176
0:7:19,7 --> 0:7:22,61
然后再从unsorted bean里面呢去呃

177
0:7:22,61 --> 0:7:25,29
进行转移到small bean和垃圾bean

178
0:7:25,29 --> 0:7:25,69
好

179
0:7:25,69 --> 0:7:29,8
我们最开始是放在unsoted bean里面

180
0:7:29,8 --> 0:7:33,2
接下来我们再来看一下关于mango的线程

181
0:7:33,2 --> 0:7:35,47
安全以及加锁力度的问题

182
0:7:35,47 --> 0:7:37,45
我们先需要注意的是

183
0:7:37,45 --> 0:7:40,289
我们的arena跟线程之间的关系

184
0:7:40,289 --> 0:7:43,249
我们知道有主线程和子线程之分

185
0:7:43,249 --> 0:7:45,329
主线程呢就是我们的main函数入口

186
0:7:45,329 --> 0:7:47,289
还是作为入口函数直接进入的

187
0:7:47,289 --> 0:7:48,45
就是我们的主线程

188
0:7:48,45 --> 0:7:49,13
然后呢

189
0:7:49,13 --> 0:7:52,41
就是我们在主线程当中通过调用pthread create

190
0:7:52,41 --> 0:7:53,98
来创建子线程

191
0:7:53,98 --> 0:7:55,78
那么这两种线程呢

192
0:7:55,78 --> 0:7:58,26
它们对应的arena呢是不太一样的

193
0:7:58,26 --> 0:8:0,14
那么我们先来看一下这里呢

194
0:8:0,14 --> 0:8:2,0
arena的数量限制的问题

195
0:8:2,0 --> 0:8:3,28
在32位下面

196
0:8:3,28 --> 0:8:6,64
就是我们看CPU的核心数是两倍的CPU核心数

197
0:8:6,64 --> 0:8:9,54
64位下是八倍的CPU的核心数

198
0:8:9,54 --> 0:8:11,62
如果我们开启的线程数

199
0:8:11,62 --> 0:8:14,94
没有超过我们的线程数量的话

200
0:8:14,94 --> 0:8:19,49
那么我们每个线程各自都会有自己的arena

201
0:8:19,49 --> 0:8:22,67
然后我们会通过一个细粒度的锁

202
0:8:22,67 --> 0:8:25,15
也就是每一个arena都会对应着一个复制锁

203
0:8:25,15 --> 0:8:27,9
来避免全局竞争

204
0:8:27,9 --> 0:8:28,59
如果是小于它的话

205
0:8:28,59 --> 0:8:30,33
那么各自用自己的arena

206
0:8:30,33 --> 0:8:32,829
那么这里呢是没有锁碰撞的

207
0:8:32,829 --> 0:8:36,449
那么接下来就是如果超过了arena的限制的话

208
0:8:36,449 --> 0:8:39,109
也就是超过刚刚的八倍的核心数

209
0:8:39,109 --> 0:8:40,43
或者两倍的核心数

210
0:8:40,43 --> 0:8:42,19
看不同的系统下面

211
0:8:42,19 --> 0:8:44,79
那么他们可能会导致锁竞争

212
0:8:44,79 --> 0:8:47,61
因为他们可能会去共享arena

213
0:8:47,61 --> 0:8:50,49
另外一个就是分配大内存的时候

214
0:8:50,49 --> 0:8:51,97
大于188KB的时候

215
0:8:51,97 --> 0:8:54,41
我们直接通过main map来进行分配

216
0:8:54,41 --> 0:8:56,3
无需经过arena锁

217
0:8:56,3 --> 0:8:59,18
这样子呢主要的目的为什么大家应该了解到

218
0:8:59,18 --> 0:9:0,81
就是为什么子线程

219
0:9:0,81 --> 0:9:5,31
子线程它在进行创建arena的时候

220
0:9:5,31 --> 0:9:7,65
要通过MAMMAP来进行创建

221
0:9:7,65 --> 0:9:10,265
因为这样子避免了去加锁

222
0:9:11,13 --> 0:9:13,57
然后呢就是我们来考虑一下

223
0:9:13,57 --> 0:9:17,17
如何与系统调用动态交互的问题

224
0:9:17,17 --> 0:9:20,18
那么在这里我们需要明确大内存分配

225
0:9:20,18 --> 0:9:22,67
就是不管你是主线程还是其他线程

226
0:9:22,67 --> 0:9:25,31
大内存分配也就是大于188KB的时候

227
0:9:25,31 --> 0:9:26,99
都是通过main map释放

228
0:9:26,99 --> 0:9:30,82
是通过main map小内存在主线程当中呢

229
0:9:30,82 --> 0:9:32,58
是通过BRK分配内存的

230
0:9:32,58 --> 0:9:35,13
就是最开始error arena

231
0:9:35,13 --> 0:9:37,33
它是通过BRK来进行分配的

232
0:9:37,33 --> 0:9:40,67
好未来如果arena里面的数据全部用完了

233
0:9:40,67 --> 0:9:44,27
那么呢我们会通过BRK这个系统调用

234
0:9:44,27 --> 0:9:46,21
继续去扩展好

235
0:9:46,21 --> 0:9:47,89
继续扩展我们的堆区

236
0:9:47,89 --> 0:9:49,59
它是一个连续的主线程

237
0:9:49,59 --> 0:9:51,87
它是一个连续的空堆空间

238
0:9:51,87 --> 0:9:55,49
然后子线程呢它是可以管理多个堆栈呃

239
0:9:55,49 --> 0:9:56,9
堆区的

240
0:9:56,9 --> 0:9:59,449
因为它会通过map map来进行分配内存

241
0:9:59,449 --> 0:10:1,529
它是从我们的文件映射区

242
0:10:1,529 --> 0:10:3,82
它是有多个堆区的

243
0:10:3,82 --> 0:10:7,29
好就是每次有一兆B啊

244
0:10:7,29 --> 0:10:9,44
通过MMAP来进行分配

245
0:10:9,44 --> 0:10:13,12
主线程是通过BRK来拓展堆断的

246
0:10:13,12 --> 0:10:14,44
由他来分配

247
0:10:14,44 --> 0:10:16,62
同时呢也由它来进行拓展

248
0:10:16,62 --> 0:10:17,7
这是BRK

249
0:10:17,7 --> 0:10:22,99
最终也是由BRK来释放堆栈空间的子线程

250
0:10:22,99 --> 0:10:25,75
它是通过main map来分配新的hip

251
0:10:25,75 --> 0:10:26,95
如果我们的空间用

252
0:10:26,95 --> 0:10:30,37
就是这个子线程所对应的arena用完了之后

253
0:10:30,37 --> 0:10:32,91
他可能会分配新的堆段

254
0:10:32,91 --> 0:10:35,25
那么呢就是通过main map来进行分配的

255
0:10:35,25 --> 0:10:39,38
它不是通过BRK好一个thread arena

256
0:10:39,38 --> 0:10:40,86
也就是子线程的arena

257
0:10:40,86 --> 0:10:43,86
它可以维护多个hip好

258
0:10:43,86 --> 0:10:47,31
我们整体总结一下关于my loft的底层实现

259
0:10:47,31 --> 0:10:48,19
也就是g lab7

260
0:10:48,19 --> 0:10:50,27
它的底层实现呢我们可以这么回答

261
0:10:50,27 --> 0:10:53,409
首先对于大内存大于128KD

262
0:10:53,409 --> 0:10:55,429
我们从通过MAMMAP分配

263
0:10:55,429 --> 0:10:58,34
通过on mmap进行释放

264
0:10:58,34 --> 0:10:59,98
小于188KB的时候

265
0:10:59,98 --> 0:11:0,86
我们需要考虑

266
0:11:0,86 --> 0:11:3,56
核心数据结构与核心数据结构之间的关系

267
0:11:3,56 --> 0:11:7,3
另外一个呢考虑行为分配与释放核心数据结构

268
0:11:7,3 --> 0:11:9,85
大家要知道arena trunk和beans之间的关系

269
0:11:9,85 --> 0:11:10,93
arena是容器

270
0:11:10,93 --> 0:11:12,7
trunk是分配的单位

271
0:11:12,7 --> 0:11:16,22
beans是管理里面的空闲块的分配和释放

272
0:11:16,22 --> 0:11:18,66
我们需要知道它的分配的逻辑

273
0:11:19,66 --> 0:11:20,58
找到arena

274
0:11:20,58 --> 0:11:25,2
然后从bans里面去找到合适的位置呢

275
0:11:25,2 --> 0:11:26,5
去进行分配

276
0:11:26,5 --> 0:11:27,53
优先从fast bean

277
0:11:27,53 --> 0:11:28,37
Assorted bean

278
0:11:28,37 --> 0:11:28,93
Small bean

279
0:11:28,93 --> 0:11:31,9
like bean里面去进行查查找

280
0:11:31,9 --> 0:11:32,3
没有的话

281
0:11:32,3 --> 0:11:32,87
Top trunk

282
0:11:32,87 --> 0:11:34,21
top trunk不足的话

283
0:11:34,21 --> 0:11:36,9
就通过BRK来进行拓展

284
0:11:36,9 --> 0:11:41,5
或者是通过main map去分配新的堆段

285
0:11:41,25 --> 0:11:43,41
那么如果是释放呢

286
0:11:43,41 --> 0:11:45,61
释放我们先优先加入fast bean

287
0:11:45,61 --> 0:11:46,63
如果是小内存

288
0:11:46,63 --> 0:11:49,62
其他的内存我们都放在on sorted bean

289
0:11:49,62 --> 0:11:50,72
那很多朋友说

290
0:11:50,72 --> 0:11:53,66
如果small small chunk跟light trunk

291
0:11:53,66 --> 0:11:55,86
为什么不放在small beans

292
0:11:55,86 --> 0:11:56,5
Lat beans

293
0:11:56,5 --> 0:11:58,46
大家需要注意是我们在分配的时候

294
0:11:58,46 --> 0:11:59,76
如果未来检索失败

295
0:11:59,76 --> 0:12:1,9
那么会从UNSOBEAN当中呢

296
0:12:1,9 --> 0:12:4,74
去以转移到small bean或者是LUBEAN

297
0:12:4,74 --> 0:12:4,98
好

298
0:12:4,98 --> 0:12:7,0
这个时机问题大家需要知道

299
0:12:7,0 --> 0:12:10,339
接下来我们再来考虑一下线程安全的问题

300
0:12:10,339 --> 0:12:14,899
MALLOG呢它的线程安全是跟arena相关的

301
0:12:14,899 --> 0:12:17,259
arena它会对应着一个细粒度的锁

302
0:12:17,259 --> 0:12:18,819
也就是一个互质锁

303
0:12:18,819 --> 0:12:21,559
那如果没有超过这个数量限制的时候

304
0:12:21,559 --> 0:12:25,139
那么呢它们是大家是互相不干扰的

305
0:12:25,139 --> 0:12:26,27
没有数据竞争

306
0:12:26,27 --> 0:12:27,75
如果超过了的话

307
0:12:27,75 --> 0:12:30,39
那么会出现共享arena的问题

308
0:12:30,39 --> 0:12:33,0
比如说有六六十五个线程

309
0:12:33,0 --> 0:12:34,64
那么我们在这里呢64位

310
0:12:34,64 --> 0:12:37,27
下面八核心有64个线程

311
0:12:37,27 --> 0:12:38,87
那么其中有一个线程呢

312
0:12:38,87 --> 0:12:40,47
它就没有独自的arena

313
0:12:40,47 --> 0:12:42,72
那么呢它就需要跟前64个线程

314
0:12:42,72 --> 0:12:44,32
去共享一个arena

315
0:12:44,32 --> 0:12:47,4
那么它会依次去找到空闲的arena

316
0:12:47,4 --> 0:12:49,12
然后去复用它好

317
0:12:49,12 --> 0:12:51,18
那这里呢就会出现锁竞争的问题

318
0:12:51,18 --> 0:12:52,56
如果都没有找到空闲呢

319
0:12:52,56 --> 0:12:55,3
它就可能发生阻塞好

320
0:12:55,3 --> 0:12:57,12
还有一个呢就是分配大内存的时候

321
0:12:57,12 --> 0:13:0,14
好避免我们的性锁竞争

322
0:13:0,14 --> 0:13:2,76
那么我们会通过map map去进行分配

323
0:13:2,76 --> 0:13:6,19
因为呢它不需要经过arena锁好

324
0:13:6,19 --> 0:13:8,21
如何与系统调用的动态交互

325
0:13:8,21 --> 0:13:9,91
那么我们要知道这些行为

326
0:13:9,91 --> 0:13:13,6
哪一些跟哪些系统调用有关系

327
0:13:13,6 --> 0:13:13,4
好

328
0:13:13,4 --> 0:13:16,4
大内存分配就是不管你是主线程还是其他线程

329
0:13:16,4 --> 0:13:18,81
大内存分配的时候都是通过main map

330
0:13:18,81 --> 0:13:20,75
然后释放的时候main map

331
0:13:20,75 --> 0:13:22,15
然后小内存的时候

332
0:13:22,15 --> 0:13:24,55
在主线程是通过BR配小内存

333
0:13:24,55 --> 0:13:26,97
在其他线程是通过main map

334
0:13:26,97 --> 0:13:30,85
主线程是通过BRK拓展的堆一段

335
0:13:31,27 --> 0:13:33,21
最终也是由BRK来释放

336
0:13:33,21 --> 0:13:35,59
子线程是通过map进行分配

337
0:13:35,59 --> 0:13:39,33
新的堆断释放的时候呢通过MMAP进行释放

338
0:13:39,33 --> 0:13:43,1
好这个呢是关于mmy log相关的面试题

339
0:13:43,1 --> 0:13:45,1
大家如果需要本视频资料的朋友

340
0:13:45,1 --> 0:13:46,25
可以一键三连加关注

341
0:13:46,25 --> 0:13:47,18
谢谢大家

