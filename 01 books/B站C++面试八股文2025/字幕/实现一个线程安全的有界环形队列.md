链接: https://www.bilibili.com/video/BV1z8WbzZESA?spm_id_from=333.788.videopod.episodes&p=7

## 字幕

1
0:0:0,76 --> 0:0:1,12
Hello

2
0:0:1,12 --> 0:0:1,32
大家好

3
0:0:1,32 --> 0:0:2,4
我是马克

4
0:0:2,4 --> 0:0:3,56
今天跟大家分享一个面试题

5
0:0:3,56 --> 0:0:5,39
腾讯C加e ma

6
0:0:5,39 --> 0:0:8,85
实现一个线程安全的有界环形队列

7
0:0:8,85 --> 0:0:10,67
我们看一下题目

8
0:0:10,67 --> 0:0:13,98
要求支持多线程环境下的并发

9
0:0:13,98 --> 0:0:16,109
push和pop操作队列

10
0:0:16,109 --> 0:0:17,409
有固定容量

11
0:0:17,409 --> 0:0:19,709
满时push操作要阻塞

12
0:0:19,709 --> 0:0:22,13
空时pop操作要阻塞

13
0:0:22,13 --> 0:0:24,49
不允许使用第三方库

14
0:0:24,49 --> 0:0:27,29
只能使用C加11标准库

15
0:0:27,53 --> 0:0:28,61
写完之后呢

16
0:0:28,61 --> 0:0:32,19
要说明你的实现如何保证线程安全

17
0:0:32,19 --> 0:0:35,19
而且要分析可能的性能瓶颈

18
0:0:35,19 --> 0:0:37,79
那我们先来分析一下题目要求

19
0:0:38,83 --> 0:0:42,16
因为在这里提供了有界的环形队列

20
0:0:42,16 --> 0:0:46,4
这里呢还说出了队列有固定的容量

21
0:0:46,26 --> 0:0:49,5
也提到要用C加11的标准库

22
0:0:49,5 --> 0:0:54,4
那么我们可能需要考虑的是vector或者是error

23
0:0:54,4 --> 0:0:57,4
那我们到底是使用vector还是error呢

24
0:0:57,4 --> 0:1:0,75
那在这里我们看到这个固定容量

25
0:1:0,75 --> 0:1:5,7
很多朋友会想到我们用error error呢

26
0:1:5,7 --> 0:1:7,14
它是固定容量的

27
0:1:7,14 --> 0:1:9,0
但是它会有一个问题

28
0:1:9,0 --> 0:1:13,2
因为呢他需要提供一个编译器的常量

29
0:1:13,2 --> 0:1:16,2
但是有的时候呢我们使用这个环形队列

30
0:1:16,2 --> 0:1:18,66
可能是通过比如说配置

31
0:1:18,66 --> 0:1:21,38
把这个环形队列的长度呢

32
0:1:21,38 --> 0:1:23,7
传入到我们的程序里面来的

33
0:1:23,7 --> 0:1:26,86
那就不能够提供一个编译器的常量

34
0:1:26,86 --> 0:1:29,81
那么我们可能是需要一个运行期的常量

35
0:1:29,81 --> 0:1:33,899
那所以我们在这里呢最好是使用vector啊

36
0:1:33,899 --> 0:1:36,279
这个呢是关于我们cc加标准库

37
0:1:36,279 --> 0:1:38,759
如何来实现这个固定容量

38
0:1:38,759 --> 0:1:42,479
那么我们在这里选定了用vector

39
0:1:47,74 --> 0:1:50,6
第二个我们再来看一下

40
0:1:50,96 --> 0:1:55,52
这里要实现有界的环形队列

41
0:1:55,52 --> 0:1:58,81
环形队列呢就是循环队列

42
0:1:58,81 --> 0:2:2,45
那循环队列我们要考虑到要有两个索引

43
0:2:2,45 --> 0:2:4,23
一个呢是生产者索引

44
0:2:4,23 --> 0:2:6,79
还要有一个呢消费者索引好

45
0:2:6,79 --> 0:2:11,14
那么等会儿呢我们用heard和tell来进行描述

46
0:2:11,14 --> 0:2:11,78
Hard

47
0:2:11,78 --> 0:2:14,2
我们就用消费者的索引

48
0:2:14,2 --> 0:2:17,82
那tell呢就是生产者的索引

49
0:2:18,29 --> 0:2:22,55
接着我们再来看一下满时push操作要阻塞

50
0:2:22,55 --> 0:2:24,49
空时pop操作要阻塞

51
0:2:24,49 --> 0:2:27,63
那这里我们需要用两个条件变量

52
0:2:27,63 --> 0:2:32,35
而且这里呢多线程并发的线程安全的

53
0:2:32,35 --> 0:2:33,39
那么大家需要注意

54
0:2:33,39 --> 0:2:35,62
我们在这里呢需要使用到一个复制锁

55
0:2:35,62 --> 0:2:37,28
两个条件变量

56
0:2:37,28 --> 0:2:41,85
一个条件变量控制破push操作满时要阻塞

57
0:2:41,85 --> 0:2:45,18
另外一个呢是pop操作空时要阻塞

58
0:2:45,46 --> 0:2:47,7
接下来我们来看具体的代码实现

59
0:2:47,7 --> 0:2:49,1
因为代码呢比较简单

60
0:2:49,1 --> 0:2:51,89
我们就没有带大家一起来手撕了

61
0:2:51,89 --> 0:2:55,89
但是我们来看一下具体我们怎么进行展开

62
0:2:55,89 --> 0:2:57,35
把这个代码写完

63
0:2:57,35 --> 0:3:0,21
首先呢我们需要考虑到这个数据

64
0:3:0,21 --> 0:3:3,81
也就是我们如何来写这个数据结构

65
0:3:3,81 --> 0:3:7,23
数据结构当中也就是我们的私有成员变量

66
0:3:7,23 --> 0:3:8,99
那么会有哪些数据呢

67
0:3:8,99 --> 0:3:10,73
首先这里呢是vector

68
0:3:10,73 --> 0:3:13,72
那么我们通过模板参数T1传入

69
0:3:13,72 --> 0:3:16,22
接着呢就是capacity

70
0:3:16,22 --> 0:3:18,0
也就是我们具体的一个容量

71
0:3:18,0 --> 0:3:19,72
那么通常呢我们刚刚说了

72
0:3:19,72 --> 0:3:25,78
要通过这个传参的构造函数当中来进行设定

73
0:3:25,78 --> 0:3:26,74
我们的大小

74
0:3:27,74 --> 0:3:32,61
接着一个是消费者是索引

75
0:3:32,61 --> 0:3:34,53
另外一个呢是生产者索引

76
0:3:34,53 --> 0:3:36,37
这个呢是互斥锁

77
0:3:36,37 --> 0:3:37,75
两个条件变量

78
0:3:37,75 --> 0:3:39,53
一个note for那一个

79
0:3:39,53 --> 0:3:41,329
另外一个是not empty

80
0:3:41,329 --> 0:3:41,809
好

81
0:3:41,809 --> 0:3:42,769
那么大家需要注意

82
0:3:42,769 --> 0:3:44,729
我们呢是一个循环队列

83
0:3:44,729 --> 0:3:45,869
环形队列

84
0:3:45,869 --> 0:3:49,57
环形队列呢物理上是不存在的

85
0:3:49,57 --> 0:3:52,14
我们只能够从逻辑上来实现

86
0:3:52,14 --> 0:3:54,6
逻辑上怎么来实现环形队列呢

87
0:3:54,6 --> 0:3:57,44
那么我们就需要对这个heard跟tell呢

88
0:3:57,44 --> 0:4:0,45
要对整个数组的长度进行取

89
0:4:0,45 --> 0:4:3,43
而我们整个数组的长度呢就是capacity

90
0:4:3,43 --> 0:4:7,34
那么这里呢会涉及到一个取余操作

91
0:4:7,34 --> 0:4:8,4
那么这样子呢

92
0:4:8,4 --> 0:4:13,0
就能够实现一个逻辑上的环形队列

93
0:4:13,0 --> 0:4:16,32
然后我们再来看一下我们需要提供哪些接口呢

94
0:4:16,32 --> 0:4:19,539
第一个是给生产者的接口push

95
0:4:19,539 --> 0:4:21,699
大家需要注意生产者的时候

96
0:4:21,699 --> 0:4:26,22
我们需要提供一个是否满

97
0:4:26,22 --> 0:4:28,65
判断是否满的这样的一个操作

98
0:4:28,65 --> 0:4:31,21
那pop操作消费者呢我们要判空

99
0:4:31,21 --> 0:4:33,5
也就是生产者判满

100
0:4:33,5 --> 0:4:34,56
消费者判空

101
0:4:34,56 --> 0:4:36,96
然后我们再来看一下这个push

102
0:4:36,96 --> 0:4:39,76
因为我们要把外部元素呢传入到里面

103
0:4:39,76 --> 0:4:43,29
那么这里可能会涉及到一些问题啊

104
0:4:43,29 --> 0:4:47,19
一个呢是我们需要通过左值传进来

105
0:4:47,19 --> 0:4:48,99
那么这里呢是要通过也

106
0:4:48,99 --> 0:4:51,38
这里未来呢是会有一个复制操作

107
0:4:51,38 --> 0:4:55,38
那么还有一个呢就是通过移动语义把资源传递

108
0:4:55,38 --> 0:4:56,83
通过参数传递过来

109
0:4:56,83 --> 0:4:58,65
那么我们为了复用代码

110
0:4:58,65 --> 0:5:1,47
就是把既支持我们的左值引用

111
0:5:1,47 --> 0:5:3,97
又支持右值引用的方式

112
0:5:3,97 --> 0:5:8,1
那么我们用一个完美转发的方式来进行实现

113
0:5:8,25 --> 0:5:10,25
当我们这里为满的时候呢

114
0:5:10,25 --> 0:5:13,44
那么我们在这里就会阻塞在23行

115
0:5:13,72 --> 0:5:14,4
接着呢

116
0:5:14,4 --> 0:5:16,4
就是把具体的元素呢

117
0:5:16,4 --> 0:5:18,78
传入到我们的这个buffer里面去

118
0:5:18,78 --> 0:5:24,29
接着再把我们的生产者的索引呢进行加一

119
0:5:24,73 --> 0:5:29,59
同时我们还要去通知一个额维空

120
0:5:29,59 --> 0:5:34,46
就是因为空而阻塞在我们的线程上面的

121
0:5:34,46 --> 0:5:39,7
那个线程为空等条件上的那个线程

122
0:5:39,7 --> 0:5:40,15
pop操作

123
0:5:40,15 --> 0:5:42,51
大家需要注意我们这个参数的设定

124
0:5:42,51 --> 0:5:46,81
参数是bl跟T类型的item

125
0:5:46,81 --> 0:5:48,45
这里呢是一个引用好

126
0:5:48,45 --> 0:5:50,169
为什么采用这种方式呢

127
0:5:50,169 --> 0:5:53,169
因为我们想要知道是不是成功的

128
0:5:53,169 --> 0:5:55,59
往里面弹出元素了

129
0:5:55,59 --> 0:5:56,19
好

130
0:5:56,19 --> 0:6:1,5
那在这里呢比如说我们这里呢有一个weight啊

131
0:6:2,54 --> 0:6:5,39
那这里呢也可以用T啊

132
0:6:5,39 --> 0:6:7,95
因为我们在这里为什么这么写呢

133
0:6:7,95 --> 0:6:10,83
就是可能未来我们需要进行一个扩展

134
0:6:10,83 --> 0:6:13,6
就是我想提供一个接口

135
0:6:13,6 --> 0:6:15,92
我们的线程阻塞在这里

136
0:6:15,92 --> 0:6:19,72
然后呢我们想要notify all把所有的线程唤醒

137
0:6:19,72 --> 0:6:21,92
然后进行优雅退出好

138
0:6:21,92 --> 0:6:23,76
那么我们可能呢未来在这里呢

139
0:6:23,76 --> 0:6:25,38
可能会需要加一些代码

140
0:6:25,38 --> 0:6:27,97
比如说加一个标记位啊

141
0:6:27,97 --> 0:6:29,99
是不是解除阻塞

142
0:6:29,99 --> 0:6:33,33
然后呢我们在这里呢就是去进行一个判空

143
0:6:33,33 --> 0:6:34,87
比如说这里有阻塞的话

144
0:6:34,87 --> 0:6:36,43
我们直接退出好

145
0:6:36,43 --> 0:6:38,409
那么这里呢就不弹出元素了

146
0:6:38,409 --> 0:6:41,649
去进行优雅退出的这样的一个操作啊

147
0:6:41,649 --> 0:6:44,93
那么这样子呢它返回的是false啊

148
0:6:44,93 --> 0:6:49,33
这个呢是为未来代码的一个扩展好

149
0:6:49,33 --> 0:6:53,84
然后呢在这里有is empty跟is for啊

150
0:6:53,84 --> 0:6:55,68
这里我们需要去进行一个调整

151
0:6:55,68 --> 0:6:57,68
我们应该要放在private下面

152
0:6:57,68 --> 0:7:1,63
但是呢我们等一会需要有一个测试

153
0:7:1,95 --> 0:7:3,97
在后面呢需要有一个测试

154
0:7:3,97 --> 0:7:9,8
所以呢我们暂时先放在这个public public下面

155
0:7:9,8 --> 0:7:11,5
但是呢实际我们发布这个程序的时候呢

156
0:7:11,5 --> 0:7:12,74
要放在private下面

157
0:7:12,74 --> 0:7:16,739
因为大家发现了它没有现场安全

158
0:7:16,739 --> 0:7:19,67
它不是现场安全的啊

159
0:7:19,67 --> 0:7:21,73
这个具体的代码呢还是很简单的

160
0:7:21,73 --> 0:7:24,35
然后在这里是因为是我们要线程安全

161
0:7:24,35 --> 0:7:26,3
他是不允许复制的

162
0:7:26,3 --> 0:7:28,72
呃这里呢是拷贝构造函数

163
0:7:28,72 --> 0:7:30,8
这是赋值运算符重载

164
0:7:30,8 --> 0:7:32,62
这两个呢都是不允许的

165
0:7:32,62 --> 0:7:35,55
同时在这里我们没有提供移动语义

166
0:7:35,55 --> 0:7:37,75
好我们在这里没有提供移动语义

167
0:7:37,75 --> 0:7:39,89
那么我们可以通过这个类型

168
0:7:39,89 --> 0:7:43,45
是移动语义呢来进行实现好这个类型

169
0:7:43,45 --> 0:7:47,75
比如说我们可以使用这种智能指针的方式

170
0:7:47,75 --> 0:7:48,85
传入进来

171
0:7:48,85 --> 0:7:53,31
那么这样子呢呃我们就支持这种移动语义了

172
0:7:53,95 --> 0:7:56,65
最后我们还要提供一个测试代码

173
0:7:56,65 --> 0:7:56,97
好

174
0:7:56,97 --> 0:7:57,73
大家看到这里呢

175
0:7:57,73 --> 0:8:1,13
是基于google test的方式来提供的这种测试代码

176
0:8:1,13 --> 0:8:2,89
那么我们具体测试的内容

177
0:8:2,89 --> 0:8:9,75
比如说基本操作缓冲区为满的情况下啊

178
0:8:9,75 --> 0:8:12,67
接下来呢就是我们的这些行为

179
0:8:12,69 --> 0:8:15,83
然后就是move的语义

180
0:8:15,83 --> 0:8:16,57
move语义呢

181
0:8:16,57 --> 0:8:21,25
我们借助这个智能指针的方式来进行测试

182
0:8:22,22 --> 0:8:24,38
好我们这里呢测试完美转发

183
0:8:25,42 --> 0:8:29,34
以及我们的阻塞的push和pop操作

184
0:8:29,86 --> 0:8:33,3
这里呢是多线程的一个压力测试

185
0:8:34,96 --> 0:8:39,16
这个是多生产者的多生产者

186
0:8:39,16 --> 0:8:41,97
多消费者的测试好

187
0:8:41,97 --> 0:8:44,65
那么我们给大家运行一下代码

188
0:8:47,1 --> 0:8:49,0
额我这里呢使用google test

189
0:8:49,0 --> 0:8:51,6
google test呢这里没有提供main函数

190
0:8:51,6 --> 0:8:53,94
所以呢用一个杠L及test main

191
0:8:54,38 --> 0:8:58,9
我们引入google test的库里面会使用到多线程

192
0:8:58,9 --> 0:9:1,7
所以引入了这三个库

193
0:9:10,48 --> 0:9:15,78
然后执行一下所有的test呢都已经通过了

194
0:9:15,78 --> 0:9:18,54
好关于这个代码呢就跟大家介绍到这

195
0:9:18,54 --> 0:9:20,66
如果大家需要本视频资料的朋友

196
0:9:20,66 --> 0:9:22,0
可以一键三连加关注

197
0:9:22,0 --> 0:9:23,4
谢谢大家

