1
0:0:0,74 --> 0:0:1,14
Hello

2
0:0:1,14 --> 0:0:1,46
大家好

3
0:0:1,46 --> 0:0:2,4
我是马克

4
0:0:2,4 --> 0:0:3,58
今天跟大家分享一道面试题

5
0:0:3,58 --> 0:0:7,6
字节后端一面多肽解决了什么问题

6
0:0:7,6 --> 0:0:9,28
先来分析一下这个题目

7
0:0:9,28 --> 0:0:11,0
关于西加多肽

8
0:0:11,0 --> 0:0:13,58
它分为静态多态和动态多态

9
0:0:13,58 --> 0:0:17,2
静态多态是通过模板和函数重在实现的

10
0:0:17,2 --> 0:0:18,2
动态多态

11
0:0:18,2 --> 0:0:20,66
通过虚函数和继承实现的

12
0:0:20,66 --> 0:0:21,82
基于分析

13
0:0:21,82 --> 0:0:24,54
我们在这里呢给大家一个参考答案

14
0:0:24,54 --> 0:0:27,1
该参考答案呢分为两个维度

15
0:0:27,1 --> 0:0:28,76
第一个是总的维度

16
0:0:28,76 --> 0:0:30,6
第二个呢是分的维度

17
0:0:30,6 --> 0:0:32,75
我们先来看总的维度

18
0:0:32,75 --> 0:0:35,73
多态实现了接口与实现分离

19
0:0:35,73 --> 0:0:37,55
提升了代码的复用性

20
0:0:37,55 --> 0:0:40,4
扩展性和解耦能力

21
0:0:40,4 --> 0:0:40,66
分

22
0:0:40,66 --> 0:0:44,18
我们分别从动态多态和静态多态来阐述

23
0:0:44,18 --> 0:0:46,15
接口与实现分离

24
0:0:46,15 --> 0:0:49,37
动态多态它是通过虚函数和继承

25
0:0:49,37 --> 0:0:53,82
在运行时决定调用哪一个实现灵活

26
0:0:53,82 --> 0:0:57,76
但有开销适合面向对象编程

27
0:0:57,76 --> 0:1:2,26
在这里呢我们有提到动态多态通过什么实现

28
0:1:2,26 --> 0:1:6,54
怎么来实现接口与实现分离

29
0:1:7,25 --> 0:1:10,45
这里接口与实现的通常是对应着一个接口

30
0:1:10,45 --> 0:1:11,91
对应着多个实现

31
0:1:11,91 --> 0:1:16,5
然后呢我们是在运行时决定调用哪一个实现

32
0:1:16,54 --> 0:1:19,38
同时我们也介绍了它的特性灵活

33
0:1:19,38 --> 0:1:20,4
但有开销

34
0:1:20,4 --> 0:1:24,65
这里的开销主要是指我们会多一次内存访问

35
0:1:24,65 --> 0:1:26,43
因为呢我们是通过虚函数调用

36
0:1:26,43 --> 0:1:28,47
虚函数调用跟普通函数的调用呢

37
0:1:28,47 --> 0:1:30,57
它是多一次内存访问

38
0:1:30,57 --> 0:1:32,75
因为我们需要通过虚函数指针

39
0:1:32,75 --> 0:1:36,24
在虚函数表去查找对应的实现

40
0:1:36,52 --> 0:1:38,82
同时我们也介绍了动态多态

41
0:1:38,82 --> 0:1:40,22
它适合的场景

42
0:1:40,22 --> 0:1:42,12
它适合面对对象编程

43
0:1:42,12 --> 0:1:44,37
尤其是设计模式当中

44
0:1:44,73 --> 0:1:47,99
接着我们来阐述动态静态多态

45
0:1:47,99 --> 0:1:51,76
静态多态呢是通过模板和函数重载来实现的

46
0:1:51,76 --> 0:1:55,139
它在编译时生成具体的实现

47
0:1:55,139 --> 0:1:57,99
高效且安全

48
0:1:57,99 --> 0:2:1,63
这个高效主要是指我们在编译期来进行开展的

49
0:2:1,63 --> 0:2:5,29
而且呢它没有动态多态依赖继承

50
0:2:5,29 --> 0:2:6,95
我们这里呢是无需继承

51
0:2:6,95 --> 0:2:9,79
只需要满足接口即可

52
0:2:9,79 --> 0:2:13,11
而且呢因为是在静态的时候

53
0:2:13,11 --> 0:2:15,83
静啊静态编译的时候来实现的

54
0:2:15,83 --> 0:2:17,79
所以呢它可以内联优化

55
0:2:17,79 --> 0:2:21,84
而动态多态它是没法进行内联优化的

56
0:2:21,84 --> 0:2:24,84
而且呢动态多态它是比较安全的

57
0:2:24,84 --> 0:2:27,38
因为呢它会在编译期进行类型检查

58
0:2:27,38 --> 0:2:28,98
而动态多态

59
0:2:28,98 --> 0:2:32,499
那么我们可能是一个鸡肋

60
0:2:32,499 --> 0:2:34,719
多个对多个子类对象

61
0:2:34,719 --> 0:2:37,659
多个子类对象呢可能没有去重在实现

62
0:2:37,659 --> 0:2:40,459
那么这里呢可能会不安全

63
0:2:40,859 --> 0:2:44,159
而且它的适用场景是适合泛型编程

64
0:2:44,159 --> 0:2:47,479
这个呢是我们关于给大家所说的参考答案

65
0:2:47,479 --> 0:2:49,99
接接着我们来进行分析

66
0:2:50,4 --> 0:2:53,84
接口与实现分离呢在这里通常是一个接口

67
0:2:53,84 --> 0:2:54,87
多个实现

68
0:2:54,87 --> 0:2:57,41
那么我们通常依赖的是接口

69
0:2:57,41 --> 0:2:59,85
而不是具体的实现

70
0:3:0,9 --> 0:3:3,89
那么在这里呢接口对应的就是做什么实现

71
0:3:3,89 --> 0:3:5,29
对应的是怎么做的问题

72
0:3:5,29 --> 0:3:9,9
也就是我们把做什么和怎么做进行了一个分离

73
0:3:9,62 --> 0:3:13,58
然后我们再来看一下关于复用性

74
0:3:13,58 --> 0:3:17,57
扩展性以及解耦能力怎么来理解

75
0:3:17,57 --> 0:3:20,7
大家可以看到这里呢是静态多态

76
0:3:20,7 --> 0:3:20,69
静态多态

77
0:3:20,69 --> 0:3:22,57
我们在这里呢通过一个模板

78
0:3:22,57 --> 0:3:25,769
模板呢我们依赖一个具体的类型

79
0:3:25,769 --> 0:3:26,929
那么我们在这里呢

80
0:3:26,929 --> 0:3:29,229
不要求这个类型的有继承关系

81
0:3:29,229 --> 0:3:33,62
我们只依赖这个类型有对应的实现就可以了

82
0:3:33,62 --> 0:3:35,76
我们这里呢依赖一个draw的实现

83
0:3:35,76 --> 0:3:37,92
那么我们这里的cycle以及score

84
0:3:37,92 --> 0:3:42,11
他们只需要实现做这个函数就行了

85
0:3:42,31 --> 0:3:43,35
那么我们在这里呢

86
0:3:43,35 --> 0:3:45,41
会进行一个编译时的一个绑定

87
0:3:45,41 --> 0:3:47,81
也就是呢我们会根据cycle score

88
0:3:47,81 --> 0:3:53,37
去实现单独的这种DRA编译器生成对应的代码

89
0:3:53,37 --> 0:3:55,41
那么这里的复用主要体现在

90
0:3:55,41 --> 0:3:57,89
我们复用了这个做的模板

91
0:3:57,97 --> 0:4:2,9
那么适用于任何有做的方法的类型

92
0:4:2,9 --> 0:4:5,63
也就是说我不需要有继承关系的这种类型

93
0:4:5,63 --> 0:4:10,41
同时它的扩展我们新增具体的做的类型的

94
0:4:10,41 --> 0:4:13,45
就是带做实现的这种类型的时候呢

95
0:4:13,45 --> 0:4:15,51
我们只需要实现这个方法

96
0:4:15,51 --> 0:4:20,51
不需要去修改这个做的模板函数

97
0:4:21,45 --> 0:4:23,79
接着呢就是他解耦

98
0:4:23,79 --> 0:4:26,83
解耦呢是做它不依赖鸡肋

99
0:4:26,83 --> 0:4:29,51
它仅依赖这种影视的接口

100
0:4:29,51 --> 0:4:31,83
也就是我们这类型的影视接口

101
0:4:31,83 --> 0:4:33,45
这个呢是他的解偶

102
0:4:33,45 --> 0:4:36,24
然后我们再来看一下动态的多肽

103
0:4:36,44 --> 0:4:38,2
大家看到动态的动态当中呢

104
0:4:38,2 --> 0:4:39,74
我们这里呢有一个round all

105
0:4:39,74 --> 0:4:40,68
round all当中

106
0:4:40,68 --> 0:4:42,62
我们会基于一个vector当中

107
0:4:42,62 --> 0:4:45,2
有一个鸡肋指针sharp

108
0:4:45,2 --> 0:4:45,7
然后呢

109
0:4:45,7 --> 0:4:49,7
我们会去调用这个容器当中所有的做的方法

110
0:4:49,7 --> 0:4:51,24
那么大家会发现呢

111
0:4:51,24 --> 0:4:55,57
我们复用了RALL这样的一个代码

112
0:4:55,57 --> 0:4:57,73
那么如果我们进行新增的时候呢

113
0:4:57,73 --> 0:5:2,21
只需要在vector当中去添加对应的sharp图形

114
0:5:2,21 --> 0:5:3,33
就行了

115
0:5:3,33 --> 0:5:5,75
那扩展呢我们只需要新增

116
0:5:5,75 --> 0:5:8,51
但是呢我们需要继承继承这个鸡肋

117
0:5:8,51 --> 0:5:13,71
并且呢要实现重载这个做的函数好

118
0:5:13,71 --> 0:5:16,31
他同时不需要修改RALL的代码

119
0:5:16,31 --> 0:5:18,52
这个呢复用和扩展

120
0:5:18,52 --> 0:5:23,76
然后就是解耦我们run all只依赖我们的抽象

121
0:5:23,76 --> 0:5:25,42
也就是依赖这个接口

122
0:5:25,42 --> 0:5:27,62
不依赖具体的实现

123
0:5:28,6 --> 0:5:31,46
这个呢就是关于西加多肽解决了什么问题

124
0:5:31,46 --> 0:5:33,38
大家需要本视频资料的朋友

125
0:5:33,38 --> 0:5:34,66
可以一键三连加关注

126
0:5:34,66 --> 0:5:35,76
谢谢大家

