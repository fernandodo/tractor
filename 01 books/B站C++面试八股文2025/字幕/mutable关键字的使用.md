1
0:0:0,96 --> 0:0:1,72
哈喽大家好

2
0:0:1,72 --> 0:0:2,32
我是Mark

3
0:0:2,32 --> 0:0:4,8
今天跟大家分享一道面试题

4
0:0:4,8 --> 0:0:5,9
微信广告一面

5
0:0:5,9 --> 0:0:8,65
mutable关键字的使用

6
0:0:9,25 --> 0:0:12,15
先给大家说一下推荐答案

7
0:0:12,15 --> 0:0:16,74
C加mutable关键字用于修饰非静态成员变量

8
0:0:16,74 --> 0:0:20,64
使该成员变量可以在CONST成员函数当中

9
0:0:20,64 --> 0:0:22,78
允许被修改

10
0:0:23,19 --> 0:0:26,5
同时也可以用于修饰lambda表达式

11
0:0:26,5 --> 0:0:30,62
可以去掉函数调用操作符后的constant关键字

12
0:0:30,62 --> 0:0:34,3
从而可以在lambda函数体内可以修改

13
0:0:34,3 --> 0:0:36,9
暗指捕获的外部变量

14
0:0:36,9 --> 0:0:38,76
该答案呢分为两个部分

15
0:0:38,76 --> 0:0:42,9
第一个部分它用于修饰非静态成员变量

16
0:0:43,3 --> 0:0:47,32
该静态成员变量呢可以在CONST成员函数当中

17
0:0:47,32 --> 0:0:48,5
允许被修改

18
0:0:48,5 --> 0:0:51,22
大家都知道constant成员函数

19
0:0:51,22 --> 0:0:54,489
constant本质上修饰的是this指针

20
0:0:54,489 --> 0:0:55,369
也就是呢

21
0:0:55,369 --> 0:0:57,249
我们在constant成员函数当中

22
0:0:57,249 --> 0:0:59,68
不允许去修改成员变量

23
0:0:59,68 --> 0:1:2,74
那如果我们想要在CONST成员函数当中

24
0:1:2,74 --> 0:1:4,12
修改成员变量的话

25
0:1:4,12 --> 0:1:9,19
那么我们需要用beautiful关键字来修饰成员变量

26
0:1:9,39 --> 0:1:13,47
第二个可以用于修饰lambda表达式

27
0:1:13,47 --> 0:1:19,43
lambda表达式在编译期会生成函数类对象

28
0:1:19,43 --> 0:1:23,63
函数类当中会生成函数调用操作符

29
0:1:23,63 --> 0:1:25,69
比如说int operator

30
0:1:25,69 --> 0:1:26,73
括号括号

31
0:1:26,73 --> 0:1:28,1
Constant

32
0:1:29,65 --> 0:1:33,33
编译器会默认的会为我们的lambda表达式

33
0:1:33,33 --> 0:1:34,41
所生成的函数

34
0:1:34,41 --> 0:1:38,8
调用操作符呢都会用constant来进行修饰

35
0:1:38,8 --> 0:1:40,1
那如果用constant修饰的话

36
0:1:40,1 --> 0:1:43,7
那么我们就不能够在函数体内去修改

37
0:1:43,7 --> 0:1:45,58
我们捕获的变量

38
0:1:45,58 --> 0:1:49,2
尤其是暗指捕获的外部变量

39
0:1:49,2 --> 0:1:53,96
那如果我们想要在函数体内修改暗值

40
0:1:53,96 --> 0:1:55,2
捕获的外部变量的话

41
0:1:55,2 --> 0:1:58,3
那么我们希望把constant去掉

42
0:1:58,3 --> 0:2:1,35
那怎么去掉constant呢

43
0:2:1,35 --> 0:2:5,25
那么我们可以用mutable去修饰lambda表达式

44
0:2:5,25 --> 0:2:8,43
这样子呢它就可以帮我们去掉函数调用操作符

45
0:2:8,43 --> 0:2:10,4
后面的constant关键字

46
0:2:10,4 --> 0:2:13,6
等会呢我们会以具体的案例跟大家进行解释

47
0:2:13,6 --> 0:2:18,61
先来看第一个修饰非静态成员变量的案例

48
0:2:18,89 --> 0:2:22,65
这个案例呢来自手撕线程池当中的阻塞队列

49
0:2:22,65 --> 0:2:25,8
这个阻塞队列当中呢

50
0:2:25,8 --> 0:2:28,56
我们是一种多线程的运行环境

51
0:2:28,84 --> 0:2:31,72
大家看到这个size size呢

52
0:2:31,72 --> 0:2:35,32
我们用constant来进行修饰这个成员函数

53
0:2:35,32 --> 0:2:39,18
因为我们是要获取队列的大小

54
0:2:39,18 --> 0:2:41,78
但是它是一个多线程运行环境呢

55
0:2:41,78 --> 0:2:44,48
我们就需要给它进行加锁

56
0:2:44,48 --> 0:2:45,9
加锁的过程当中

57
0:2:45,9 --> 0:2:48,82
对于这个MUTEXT它会有两个操作

58
0:2:48,82 --> 0:2:50,709
加锁的时候掉lock

59
0:2:50,709 --> 0:2:52,269
释放锁的时候

60
0:2:52,269 --> 0:2:54,709
它需要调unlock

61
0:2:54,709 --> 0:3:0,28
那么这样子在lock和unlock当中都会去修改new text

62
0:3:0,28 --> 0:3:4,22
而constant它修饰了这样的一个成员函数

63
0:3:4,22 --> 0:3:6,0
相当于修饰了祭祀指针

64
0:3:6,0 --> 0:3:7,28
那么在这个函数当中

65
0:3:7,28 --> 0:3:9,6
是不允许修改我们的成员变量的

66
0:3:9,6 --> 0:3:10,2
New text

67
0:3:10,2 --> 0:3:12,13
它是属于成员变量

68
0:3:12,37 --> 0:3:15,87
那如果我们想要让他去修改的话

69
0:3:15,87 --> 0:3:17,73
所以呢我们需要用mutable

70
0:3:17,73 --> 0:3:20,18
关键字去修饰这个MUTEX

71
0:3:20,18 --> 0:3:22,26
那很多朋友就会有疑问

72
0:3:22,26 --> 0:3:24,74
什么时候去使用mutable呢

73
0:3:24,74 --> 0:3:26,34
我们刚刚使用的mutable

74
0:3:26,34 --> 0:3:29,5
有没有去破坏constant语义呢

75
0:3:29,5 --> 0:3:31,24
在这里并没有

76
0:3:31,24 --> 0:3:35,92
因为我们的语义呢是获取它的大小

77
0:3:36,2 --> 0:3:41,41
而加锁线程安全是我们的内部实现

78
0:3:41,69 --> 0:3:46,48
new tx跟我们的大小是不相关的好

79
0:3:46,48 --> 0:3:48,2
那么通常在这种情况下

80
0:3:48,2 --> 0:3:50,24
不影响对象的对外逻辑

81
0:3:50,24 --> 0:3:53,8
仅反映内部实现细节的情况下

82
0:3:53,8 --> 0:3:58,12
我们可以使用mutable关键字呢来进行修饰

83
0:3:58,48 --> 0:4:0,56
接下来我们看第二个案例

84
0:4:0,56 --> 0:4:2,78
我们用于惰性求值

85
0:4:2,78 --> 0:4:4,45
同样如此

86
0:4:4,45 --> 0:4:7,23
我们要返回的是一个对象

87
0:4:7,23 --> 0:4:8,81
other一个成员变量

88
0:4:9,81 --> 0:4:13,69
但是呢我们想要进行一个惰性求值

89
0:4:14,9 --> 0:4:16,21
当我们get other的时候

90
0:4:16,21 --> 0:4:18,27
我们先看它是否有效

91
0:4:18,27 --> 0:4:20,97
如果是无效的

92
0:4:20,97 --> 0:4:23,35
那么我们会生成这样的一个对象

93
0:4:23,35 --> 0:4:27,13
最后把这个对象呢进行一个返回

94
0:4:27,53 --> 0:4:29,49
那么大家可以看到他的语义

95
0:4:29,49 --> 0:4:31,21
对外提供的逻辑是什么

96
0:4:31,21 --> 0:4:33,79
提供的逻辑是返回这个对象

97
0:4:33,79 --> 0:4:35,83
那么我们的内部实现呢

98
0:4:35,83 --> 0:4:39,34
是要进行一个惰性求值好

99
0:4:39,34 --> 0:4:42,48
那么这个呢就是关于修饰

100
0:4:42,48 --> 0:4:44,14
非静态成员变量的案例

101
0:4:44,14 --> 0:4:45,56
帮助我们理解一下

102
0:4:45,56 --> 0:4:50,36
就是可以在CONST成员函数当中去修改成员变量

103
0:4:50,94 --> 0:4:53,94
接下来我们来看一下修饰lambda表达式

104
0:4:53,94 --> 0:4:56,64
lambda表达式本质上是一个函数对象

105
0:4:56,64 --> 0:4:59,939
或者呢是地包类的一个实例

106
0:5:0,62 --> 0:5:5,9
那么我们可以看我们LAMBA表达式当中

107
0:5:5,9 --> 0:5:9,48
第一个呢是按引用进行捕获

108
0:5:9,48 --> 0:5:11,16
按引用进行捕获的时候

109
0:5:11,16 --> 0:5:15,17
大家可以看到这里有一个函数调用操作符

110
0:5:15,17 --> 0:5:17,91
它后面呢是用constant进行修饰的

111
0:5:17,91 --> 0:5:20,32
然后大家可能会有疑问

112
0:5:20,32 --> 0:5:24,76
这个I为什么允许进行加加呢

113
0:5:24,76 --> 0:5:27,65
为什么允许修改I呢

114
0:5:27,65 --> 0:5:29,5
大家需要注意的是

115
0:5:29,5 --> 0:5:34,74
我们在这里是它的成员成员变量是引用

116
0:5:34,74 --> 0:5:38,92
那么我们通过引用去修改它的值是可以的

117
0:5:38,92 --> 0:5:43,64
但是呢你不能够修改引用的对象

118
0:5:43,64 --> 0:5:45,28
比如说你换一个引用对象

119
0:5:45,28 --> 0:5:46,58
那就是修改I

120
0:5:46,58 --> 0:5:49,48
而我们这里呢是引用I的值

121
0:5:49,48 --> 0:5:52,519
大家这个地方要知道

122
0:5:52,519 --> 0:5:54,439
然后我们再来看一下

123
0:5:54,439 --> 0:5:58,15
如果我们是按值去进行捕获呢

124
0:5:58,15 --> 0:6:0,3
按值进行捕获的时候

125
0:6:0,3 --> 0:6:2,36
大家看到函数调用操作符

126
0:6:2,36 --> 0:6:4,42
仍然是constant进行修饰

127
0:6:4,42 --> 0:6:7,22
那么我们在这里如果加加I的话

128
0:6:7,22 --> 0:6:9,2
那就会编译错误

129
0:6:9,2 --> 0:6:12,58
因为我们在这里的成员变量就是I

130
0:6:12,58 --> 0:6:15,58
那么这里呢是不可以去修改它的

131
0:6:15,58 --> 0:6:19,39
那如果我们想要修改这个I怎么办呢

132
0:6:19,39 --> 0:6:23,9
那我们可以在这里加上一个mutable关键字

133
0:6:23,9 --> 0:6:25,75
来修饰我们的lambda表达式

134
0:6:25,99 --> 0:6:27,49
那么大家可以看到

135
0:6:27,49 --> 0:6:31,6
当用mutable关键字来修饰lambda表达式的时候

136
0:6:31,6 --> 0:6:35,4
我们的函数调用操作符后面没有constant了

137
0:6:35,4 --> 0:6:38,9
而我们默认的情况下都是有constant的

138
0:6:38,9 --> 0:6:42,7
所以我们用mutable关键字去修饰lambda表达式

139
0:6:42,7 --> 0:6:46,33
就是去掉函数调用操作符后面的constant

140
0:6:46,33 --> 0:6:48,53
那么这样子我们就可以在这里面呢

141
0:6:48,53 --> 0:6:50,49
进行加加I了

142
0:6:52,64 --> 0:6:53,76
好那很多朋友说

143
0:6:53,76 --> 0:6:56,9
为什么lambda表达式默认不允许修改

144
0:6:56,9 --> 0:6:58,65
谱或变量的值呢

145
0:6:58,65 --> 0:7:2,3
这里主要是为了避免一个逻辑混淆

146
0:7:2,3 --> 0:7:5,35
我们开发者可能会误以为

147
0:7:5,35 --> 0:7:9,26
是可以修改外部的变量的好

148
0:7:9,26 --> 0:7:12,32
关于西加mutable关键字的使用呢

149
0:7:12,32 --> 0:7:13,64
就跟大家介绍到这

150
0:7:13,64 --> 0:7:16,32
需要本视频资料的朋友可以一键三连加关注

151
0:7:16,32 --> 0:7:17,22
谢谢大家

