1
0:0:0,52 --> 0:0:0,84
Hello

2
0:0:0,84 --> 0:0:1,0
大家好

3
0:0:1,0 --> 0:0:1,56
我是Mark

4
0:0:1,56 --> 0:0:2,68
今天跟大家分享一道面试题

5
0:0:2,68 --> 0:0:4,12
饮食西加开发意面

6
0:0:4,12 --> 0:0:5,5
细讲工厂模式

7
0:0:5,5 --> 0:0:8,34
我们先来了解一下工厂模式的核心思想

8
0:0:8,34 --> 0:0:10,86
他的核心思想是将对象的创建的复杂性

9
0:0:10,86 --> 0:0:12,68
隐藏在工厂内部

10
0:0:12,68 --> 0:0:14,98
而不是暴露在代码调用处

11
0:0:14,98 --> 0:0:16,439
这句话如何来理解呢

12
0:0:16,439 --> 0:0:19,27
我们对象创建包括对象的生成以及初始化

13
0:0:19,27 --> 0:0:21,43
那么我们不是暴露在代码调用处

14
0:0:21,43 --> 0:0:24,75
就是我们有多个地方呢需要调用这个对象创建

15
0:0:24,75 --> 0:0:27,76
那么如果我们多个地方都去要调用这个代码呢

16
0:0:27,76 --> 0:0:29,96
那就会出现每次更改一个部分

17
0:0:29,96 --> 0:0:31,36
我们要在多处进行修改

18
0:0:31,36 --> 0:0:33,6
那么这个时候我们可以把这个对象的创建

19
0:0:33,6 --> 0:0:35,16
也就是生成以及初始化呢

20
0:0:35,16 --> 0:0:36,64
把它隐藏在一个工厂内部

21
0:0:36,64 --> 0:0:38,43
统提出一个统一的接口

22
0:0:38,43 --> 0:0:41,51
那么这样子在多个调代码调用处呢

23
0:0:41,51 --> 0:0:43,47
那么我们都是依赖一个具体的接口

24
0:0:43,47 --> 0:0:45,44
而不是依赖一个具体的实现

25
0:0:45,44 --> 0:0:47,52
工厂模式有三种模式

26
0:0:47,52 --> 0:0:49,7
因为在这里所说的是细讲工厂模式

27
0:0:49,7 --> 0:0:51,54
那么我们需要了解这三种模式

28
0:0:51,54 --> 0:0:52,6
工厂方法

29
0:0:52,6 --> 0:0:55,41
简单工厂以及抽象工厂这三种

30
0:0:55,41 --> 0:0:57,53
那么我们现在需要通过一个具体的案例

31
0:0:57,53 --> 0:0:59,39
来理解这三者之间的差异

32
0:0:59,39 --> 0:1:1,47
以及它们分别解决了什么样的问题

33
0:1:1,47 --> 0:1:2,85
我们先来看一下这个案例

34
0:1:2,85 --> 0:1:5,11
这个案例呢是游戏角色创建

35
0:1:5,11 --> 0:1:7,79
那么假设呢我们现在玩的是一种RPG的游戏

36
0:1:7,79 --> 0:1:9,55
需要创建不同类型的角色

37
0:1:9,55 --> 0:1:11,29
其中包括战士法师

38
0:1:11,29 --> 0:1:12,21
弓箭手

39
0:1:12,21 --> 0:1:13,77
当然随着游戏的发展

40
0:1:13,77 --> 0:1:16,9
未来呢还会增加更多的角色类型

41
0:1:16,9 --> 0:1:17,25
那么不同的角色类型

42
0:1:17,25 --> 0:1:19,289
还会有不同的属性以及功能

43
0:1:19,289 --> 0:1:23,18
现在我们通过具体的代码来帮助大家理解

44
0:1:24,14 --> 0:1:24,86
大家可以看到

45
0:1:24,86 --> 0:1:26,82
在这里呢我们提前创建了一个character

46
0:1:26,82 --> 0:1:27,98
也就是一个具体的角色

47
0:1:27,98 --> 0:1:29,34
他是一个角色的鸡肋

48
0:1:29,34 --> 0:1:31,36
我们把复用的地方呢进行一个抽象

49
0:1:31,36 --> 0:1:32,24
生成一个鸡肋

50
0:1:32,24 --> 0:1:34,44
那么这个鸡肋里面包括具体的角色名

51
0:1:34,44 --> 0:1:35,72
还有他的血量

52
0:1:35,72 --> 0:1:36,82
包括攻击力

53
0:1:36,82 --> 0:1:37,96
还有魔法力

54
0:1:37,96 --> 0:1:42,2
那么现在呢我们有三种不同的角色战士

55
0:1:42,2 --> 0:1:44,0
VR继承自character

56
0:1:44,0 --> 0:1:46,3
然后他会有额外的一些技能

57
0:1:46,3 --> 0:1:49,6
另外这里呢还会有法师以及弓箭手

58
0:1:49,6 --> 0:1:50,94
那么我们都是继承自character

59
0:1:50,94 --> 0:1:54,96
那么现在我们想要去在游戏的过程当中

60
0:1:54,96 --> 0:1:55,84
生成这些对象

61
0:1:55,84 --> 0:1:58,42
那么现在我们所要想到的就是使用工厂方法

62
0:1:58,42 --> 0:1:59,8
因为我们不希望呢

63
0:1:59,8 --> 0:2:3,56
每一个调用的地方都需要去生成对应的代码

64
0:2:3,56 --> 0:2:5,56
那现在我们先来跟大家介绍

65
0:2:5,56 --> 0:2:8,8
一个简单的工厂模式

66
0:2:11,66 --> 0:2:13,24
简单工厂怎么来做呢

67
0:2:13,24 --> 0:2:18,55
简单控场他的定义是通过传入的参数动态

68
0:2:18,55 --> 0:2:20,83
决定创建哪一个产品类的实例

69
0:2:20,83 --> 0:2:24,445
所以我们这里呢就需要用一个枚举

70
0:2:29,28 --> 0:2:33,68
我们为每一种角色类型呢给它用一个枚举值

71
0:2:35,22 --> 0:2:38,74
第一个是我们的战士

72
0:2:39,18 --> 0:2:41,42
第二个呢是我们的法师

73
0:2:41,42 --> 0:2:43,42
第三个呢是弓箭手

74
0:2:45,76 --> 0:2:50,4
现在我们需要生成一个简单的工厂类

75
0:2:54,76 --> 0:2:58,24
这里我们只需要提供一个静态的方法来进行

76
0:2:58,24 --> 0:2:59,4
创建就可以了

77
0:2:59,4 --> 0:3:1,45
因为我们是通过具体的参数来进行决定的

78
0:3:1,45 --> 0:3:3,81
来决定生成什么样的一个角色啊

79
0:3:3,81 --> 0:3:5,29
我们去生产这个对象的时候呢

80
0:3:5,29 --> 0:3:7,57
就通过一个unique ptr就可以了

81
0:3:8,8 --> 0:3:12,6
返回的是一个鸡肋的unit pdr

82
0:3:14,0 --> 0:3:15,76
用大写的

83
0:3:19,559 --> 0:3:20,879
根据传入的参数

84
0:3:20,879 --> 0:3:22,679
这个参数呢就是具体的角色类型

85
0:3:22,679 --> 0:3:23,559
根据角色类型呢

86
0:3:23,559 --> 0:3:25,59
然后去创建对应的角色

87
0:3:25,59 --> 0:3:28,7
那么我们通过这个参数来传递他的角色名

88
0:3:30,78 --> 0:3:35,86
然后通过一个sweet语句来枚举这些type

89
0:3:37,1 --> 0:3:39,27
然后根据不同的type

90
0:3:43,2 --> 0:3:45,14
接下来返回好

91
0:3:45,14 --> 0:3:46,68
我们这里呢用C加14

92
0:3:46,68 --> 0:3:48,88
Make unique

93
0:3:53,38 --> 0:3:55,7
第二个呢是法师

94
0:4:5,46 --> 0:4:9,86
第三个呢是射手

95
0:4:22,74 --> 0:4:23,7
这里写错了

96
0:4:23,7 --> 0:4:25,64
Character

97
0:4:28,72 --> 0:4:30,68
那么大家可以看到这个呢

98
0:4:30,68 --> 0:4:32,28
就是实现了一个简单工厂

99
0:4:32,28 --> 0:4:35,36
那简单工厂这个简单主要体现在哪里呢

100
0:4:35,36 --> 0:4:38,14
主要体现在我们通常这一些角色类型

101
0:4:38,14 --> 0:4:40,0
它的变化不是特别频繁的情况下

102
0:4:40,0 --> 0:4:42,86
而且呢我们的角色创建它是比较简单的情况下

103
0:4:42,86 --> 0:4:44,72
我们在这里呢只有一个对象的生成

104
0:4:44,72 --> 0:4:46,0
它没有具体的一个初始化

105
0:4:46,0 --> 0:4:46,52
初始化呢

106
0:4:46,52 --> 0:4:48,68
我们可能就直接通过构造函数呢去进行初始化

107
0:4:48,68 --> 0:4:49,72
那么有的时候的角色呢

108
0:4:49,72 --> 0:4:51,62
我们还可能通过需要通过一些配置

109
0:4:51,62 --> 0:4:54,2
还需要通过其他的对象来进行初始化

110
0:4:54,2 --> 0:4:55,9
我们的这个呃具体的角色

111
0:4:55,9 --> 0:4:58,26
所以呢我们如果是在简单的情况下

112
0:4:58,26 --> 0:4:59,909
就可以通过它来进行实现

113
0:4:59,909 --> 0:5:3,11
那么随着我们的功能的不断的去加强

114
0:5:3,11 --> 0:5:4,83
比如说我们的这些不同的角色呢

115
0:5:4,83 --> 0:5:6,97
他的初始化不仅要产生这个对象

116
0:5:6,97 --> 0:5:7,65
生成这个对象

117
0:5:7,65 --> 0:5:9,76
还需要依赖其他对象来进行初始化的时候

118
0:5:9,76 --> 0:5:10,96
而且这个初始化的流程呢

119
0:5:10,96 --> 0:5:12,56
大家还会有一些公有的部分的时候

120
0:5:12,56 --> 0:5:14,7
那么我们的简称工厂呢就没法胜任了

121
0:5:14,7 --> 0:5:16,36
同时大家也会注意到一个问题

122
0:5:16,36 --> 0:5:18,42
就是简单工厂它在进行扩展的时候呢

123
0:5:18,42 --> 0:5:19,8
就比较麻烦

124
0:5:19,8 --> 0:5:21,19
比如说我现在新增一个牧师

125
0:5:21,19 --> 0:5:21,95
新增一个牧师

126
0:5:21,95 --> 0:5:22,95
那么我们需要在这个地方

127
0:5:22,95 --> 0:5:24,41
先增加一个牧师的一个类

128
0:5:24,41 --> 0:5:26,48
然后呢我们在这里面还需要加一个枚举

129
0:5:26,48 --> 0:5:27,36
加一个枚举之后

130
0:5:27,36 --> 0:5:29,6
还需要在这个啊我们的工厂方法

131
0:5:29,6 --> 0:5:32,68
这里呢还需要提供一个还提供一个case

132
0:5:32,68 --> 0:5:34,42
然后呢去进行一个创建

133
0:5:34,42 --> 0:5:35,76
那这样子呢就比较麻烦

134
0:5:35,76 --> 0:5:39,26
那么这个时候我们就可以使用工厂方法

135
0:5:41,38 --> 0:5:44,269
我们先来看一下工厂方法的案例的定义

136
0:5:44,269 --> 0:5:46,809
工厂方法呢是定义一个用于创建对象的接口

137
0:5:46,809 --> 0:5:47,569
让子类

138
0:5:47,569 --> 0:5:48,9
大家注意

139
0:5:48,9 --> 0:5:49,449
让子类决定实例化

140
0:5:49,449 --> 0:5:51,609
哪一个类工厂方法使得一个类的实例化呢

141
0:5:51,609 --> 0:5:52,249
延迟到子类

142
0:5:52,249 --> 0:5:54,13
这个呢是设计模式的

143
0:5:54,13 --> 0:5:56,35
作者给我们的工厂方法下定了一个定义

144
0:5:56,35 --> 0:5:57,99
那么我们在这里需要了解的是

145
0:5:57,99 --> 0:6:0,13
这里需要一个子类去进行实例化

146
0:6:0,13 --> 0:6:1,69
那我们的父类是用来干什么呢

147
0:6:1,69 --> 0:6:5,31
父父类来规范我们的工具体的创建流程

148
0:6:5,31 --> 0:6:8,119
比如说包括生成生成这个对象

149
0:6:8,119 --> 0:6:9,739
以及初始化这个对象

150
0:6:9,739 --> 0:6:11,559
所以呢我们现在需要在它的基础上呢

151
0:6:11,559 --> 0:6:12,519
去进行一个扩展

152
0:6:12,519 --> 0:6:15,9
我们现在基于工厂方法来实现这样的一个需求

153
0:6:16,22 --> 0:6:17,42
现在我们打开代码

154
0:6:17,42 --> 0:6:20,66
继续来实现工厂方法是如何来实现的呢

155
0:6:20,66 --> 0:6:25,14
好我们需要为角色生成一个抽象的工厂类

156
0:6:25,7 --> 0:6:26,98
Character factory

157
0:6:28,54 --> 0:6:30,54
这个呢是鸡肋

158
0:6:33,14 --> 0:6:35,7
这边我们需要去规范一下

159
0:6:35,7 --> 0:6:37,34
我们的这个具体对象的创建

160
0:6:37,34 --> 0:6:39,6
包括生成和初始化

161
0:6:39,6 --> 0:6:41,87
那么我们要通过两个接口来进行实现

162
0:6:43,33 --> 0:6:44,61
在protect里面呢

163
0:6:44,61 --> 0:6:49,59
我们给它实现一个初始化的流程啊

164
0:6:49,59 --> 0:6:49,87
当然了

165
0:6:49,87 --> 0:6:52,43
我们这里呢需要利用多态的机机制

166
0:6:55,32 --> 0:6:56,36
通过积累的

167
0:6:58,52 --> 0:7:0,96
一个指针来传递

168
0:7:3,26 --> 0:7:7,4
我们现在呢通过一个打印来描述

169
0:7:7,4 --> 0:7:9,94
默认的一个初始化的流程

170
0:7:11,5 --> 0:7:13,9
呃实际上的代码呢可能会比较复杂

171
0:7:13,9 --> 0:7:16,18
我们在这里呢是呃加上的是什么呢

172
0:7:16,18 --> 0:7:18,66
加上的是他的一个初始化流程

173
0:7:24,62 --> 0:7:26,62
角色创建完成

174
0:7:33,48 --> 0:7:35,52
然后呢我们还需要提供一个接口

175
0:7:35,52 --> 0:7:37,28
让他去创建角色啊

176
0:7:37,28 --> 0:7:39,52
因为我们这里的未来会需要使用到一个多肽

177
0:7:39,52 --> 0:7:41,8
所以呢大家一定要注意啊

178
0:7:41,8 --> 0:7:43,92
我们这里一定要提供一个虚的析构函数

179
0:7:43,92 --> 0:7:46,57
不然呢就是我们子类的析构函数呢

180
0:7:46,57 --> 0:7:48,37
不能够得到正确调用

181
0:7:48,92 --> 0:7:50,46
Character factory

182
0:7:50,46 --> 0:7:52,8
用默认生成的就行了

183
0:7:59,6 --> 0:8:3,58
好这里呢需要提供一个character

184
0:8:4,48 --> 0:8:7,72
创建我们生成我们的对象的接口

185
0:8:10,92 --> 0:8:13,8
我们这里呢没有默认的话

186
0:8:13,8 --> 0:8:14,44
没有默认的话

187
0:8:14,44 --> 0:8:17,409
我们就让它抽象成一个程序函数

188
0:8:17,409 --> 0:8:19,209
那么我们的这个character factory呢

189
0:8:19,209 --> 0:8:20,56
它就不能进行实例化了

190
0:8:20,56 --> 0:8:22,88
好接下来我们就需要通过一个模板方法

191
0:8:22,88 --> 0:8:24,68
就是定义他创建角色

192
0:8:24,68 --> 0:8:25,64
并且进行初始化

193
0:8:25,64 --> 0:8:27,96
我们真正需要的是这样的一个接口

194
0:8:34,779 --> 0:8:38,36
好加上一个with setup

195
0:8:43,179 --> 0:8:44,459
我们创建角色的时候呢

196
0:8:44,459 --> 0:8:46,259
就包括生成对象以及初始化

197
0:8:47,659 --> 0:8:50,819
所以呢我们在这里先需要生成一个角色

198
0:8:52,6 --> 0:8:54,36
先调用great

199
0:8:55,85 --> 0:8:56,57
Character

200
0:8:58,65 --> 0:9:0,69
好用上面的这个接口

201
0:9:3,4 --> 0:9:5,52
然后呢去进行初始化盘

202
0:9:11,46 --> 0:9:13,62
好获取它的裸指针来进行初始化

203
0:9:14,66 --> 0:9:16,94
最后把这个对象呢返回出去

204
0:9:19,4 --> 0:9:22,8
好这个呢工厂方法的积累就生成了

205
0:9:22,8 --> 0:9:24,72
因为呢我们要延迟到子类当中去

206
0:9:24,72 --> 0:9:26,34
进行生成以及初始化

207
0:9:26,34 --> 0:9:28,48
所以呢我们现在需要为每一个角色

208
0:9:28,48 --> 0:9:30,1
比如说先通过战士

209
0:9:30,1 --> 0:9:31,2
我们先写一个

210
0:9:31,2 --> 0:9:33,44
然后呢就可以直接复制了

211
0:9:34,59 --> 0:9:35,59
好factory

212
0:9:35,59 --> 0:9:39,8
然后继承自public character factory

213
0:9:42,54 --> 0:9:44,54
那么这里呢我们只需要实现两个接口

214
0:9:44,54 --> 0:9:46,3
第一个呢是

215
0:9:48,84 --> 0:9:50,56
第一个是great

216
0:9:52,39 --> 0:9:53,87
great呢就跟上面一样

217
0:9:53,87 --> 0:9:58,819
我们直接去make unique

218
0:9:59,419 --> 0:10:1,899
那么还有一个呢就是初始化的流程

219
0:10:4,36 --> 0:10:8,4
这个初始化的流程呢上面的部分

220
0:10:8,4 --> 0:10:10,9
我们把通用的初始化流程呢写到这里面

221
0:10:10,9 --> 0:10:13,58
额我们不同角色的初始化流程呢

222
0:10:13,58 --> 0:10:14,98
我们在这里写额外的部分

223
0:10:14,98 --> 0:10:17,34
所以呢我们把鸡肋的把他加上

224
0:10:17,34 --> 0:10:22,9
通过我们的作用域character的setup

225
0:10:27,72 --> 0:10:31,36
好然后在这里呢写我们额外的部分

226
0:10:32,7 --> 0:10:35,3
比如说我们在这里呢为战士

227
0:10:36,96 --> 0:10:38,4
为战士配备

228
0:10:40,48 --> 0:10:41,84
铁剑

229
0:10:43,78 --> 0:10:44,58
和盾牌

230
0:10:46,5 --> 0:10:49,26
这是呢他额外的一些初始化流程

231
0:10:50,94 --> 0:10:52,88
好然后我们就接着就可以复制了

232
0:10:52,88 --> 0:10:55,26
那么我们需要为每一个角色都去创建一个

233
0:10:55,26 --> 0:10:56,54
这样的对象啊

234
0:10:56,54 --> 0:11:1,99
比如说我们需要为法师创建一个factory

235
0:11:1,99 --> 0:11:6,75
在法师factory当中呢去去生成对应的对象

236
0:11:8,19 --> 0:11:12,24
然后呢我们还需要为弓箭手

237
0:11:15,42 --> 0:11:18,2
好然后我们在这里呢只需要写各自的

238
0:11:18,2 --> 0:11:20,46
比如说法师和弓箭手的内容

239
0:11:21,33 --> 0:11:23,9
这里的法师他需要的是什么呢

240
0:11:23,9 --> 0:11:25,69
比如说他的魔法师或法杖

241
0:11:30,68 --> 0:11:32,72
那对应的我们的弓箭手呢

242
0:11:32,72 --> 0:11:35,0
他就需要配备弓箭了

243
0:11:38,18 --> 0:11:38,86
和箭头

244
0:11:41,26 --> 0:11:44,24
那么至此嗯我们的工厂方法呢就实现了

245
0:11:44,24 --> 0:11:46,6
我们工厂方法怎么解决这类问题的呢

246
0:11:46,6 --> 0:11:48,32
先抽象一个工厂方法的积累

247
0:11:48,32 --> 0:11:49,7
就是角色的积累

248
0:11:49,7 --> 0:11:50,72
工厂的积累

249
0:11:50,72 --> 0:11:52,46
然后这里面定义了一个

250
0:11:52,46 --> 0:11:55,74
我们是如我们规范了这个角色创建的流程

251
0:11:55,74 --> 0:11:56,8
具体是怎么规范的呢

252
0:11:56,8 --> 0:11:58,819
就是great character with setup

253
0:11:58,819 --> 0:12:0,899
那我们的具体的角色创建

254
0:12:0,899 --> 0:12:3,359
包括角色的生成以及初始化

255
0:12:3,359 --> 0:12:5,97
我们把初始化的流程跟角色创建的流程呢

256
0:12:5,97 --> 0:12:8,49
让我们子类去进行一个实现

257
0:12:8,49 --> 0:12:10,25
好比如说我们great character

258
0:12:10,25 --> 0:12:11,53
这里为什么要用程序函数呢

259
0:12:11,53 --> 0:12:12,45
因为每一个都不一样

260
0:12:12,45 --> 0:12:13,86
所以呢我们不能够提供默认的

261
0:12:13,86 --> 0:12:16,7
那这里呢有一个括号说明它不设置成程序

262
0:12:16,7 --> 0:12:17,38
程序函数呢

263
0:12:17,38 --> 0:12:18,1
这里呢就告诉我们

264
0:12:18,1 --> 0:12:20,87
默认的也就是我们共公共的部分

265
0:12:20,87 --> 0:12:23,7
公共都需要进行初始化的部分好

266
0:12:23,7 --> 0:12:25,75
然后呢这里我们子类通过setup character呢

267
0:12:25,75 --> 0:12:28,36
就是写自己呃额外的一些初始化的流程

268
0:12:28,36 --> 0:12:29,28
那么通过这种方式呢

269
0:12:29,28 --> 0:12:30,74
我们就可以进行动态的扩展

270
0:12:30,74 --> 0:12:32,8
未来我们的角色的变动的时候

271
0:12:32,8 --> 0:12:34,32
增加一个角色的变动的时候呢

272
0:12:34,32 --> 0:12:36,14
我们都不会影响其他的角色

273
0:12:36,14 --> 0:12:38,3
而我们的简单工厂它是会进行影响的

274
0:12:38,3 --> 0:12:39,62
比如说我们现在增加一个流程

275
0:12:39,62 --> 0:12:40,98
那么这里呢需要添加代码好

276
0:12:40,98 --> 0:12:42,14
我们这里呢也需要添加代码

277
0:12:42,14 --> 0:12:43,3
那对应着great character呢

278
0:12:43,3 --> 0:12:44,31
它就不稳定了

279
0:12:44,31 --> 0:12:45,95
那同样如此

280
0:12:45,95 --> 0:12:47,55
那相反的相反的

281
0:12:47,55 --> 0:12:49,3
我们在这里呢他就不会去影响

282
0:12:49,3 --> 0:12:51,3
比如说我们现在生成了一个其他类型的

283
0:12:51,3 --> 0:12:52,39
他就不会去影响弓箭手

284
0:12:52,39 --> 0:12:53,69
也不会影响法师的代码

285
0:12:53,69 --> 0:12:55,679
这些代码都不会影响到啊

286
0:12:55,679 --> 0:12:58,93
这个呢是关于简单工厂的一种方式

287
0:12:58,93 --> 0:13:2,81
那么另外一个就是通过抽象工厂来解决问题了

288
0:13:2,81 --> 0:13:5,41
我们先来了解一下抽象工厂

289
0:13:6,32 --> 0:13:7,88
抽象工厂是提供一个接口

290
0:13:7,88 --> 0:13:11,19
用于创建相关或者是依赖对象的家族

291
0:13:11,19 --> 0:13:13,43
那前面的简单工厂工厂方法

292
0:13:13,43 --> 0:13:15,19
它都是创建一个产品

293
0:13:15,19 --> 0:13:19,83
而我们的抽象工厂呢它是看创建一个产品足

294
0:13:19,83 --> 0:13:22,57
比如说我们的麦当劳和肯德基

295
0:13:22,57 --> 0:13:26,69
麦当劳它会有一对列一一系列的产品产品族

296
0:13:26,69 --> 0:13:29,12
然后呢我们的麦当劳和肯德基

297
0:13:29,12 --> 0:13:31,56
他也会有一套自己对应的一个产品组

298
0:13:31,56 --> 0:13:32,96
那么我们现在的抽象工厂呢

299
0:13:32,96 --> 0:13:34,3
就是创建一系列的产品

300
0:13:34,3 --> 0:13:36,43
这些一系列的产品呢它们是相关联的

301
0:13:36,43 --> 0:13:38,39
那么对于我们这里而言是什么呢

302
0:13:38,39 --> 0:13:40,49
比如说我们的未来的游戏当中的发展需求

303
0:13:40,49 --> 0:13:43,67
变成我们的法师战士弓箭手

304
0:13:43,67 --> 0:13:45,89
他们三者呢我们前面还要加上一个种族

305
0:13:45,89 --> 0:13:46,97
比如说人类

306
0:13:46,97 --> 0:13:49,25
还有呢加上一个精灵好

307
0:13:49,25 --> 0:13:50,71
还有像矮人等等

308
0:13:50,71 --> 0:13:52,89
我们可能还会要前面还要加上一个种族

309
0:13:52,89 --> 0:13:55,24
另外我们可能不同的呃

310
0:13:55,24 --> 0:13:56,8
战士法师

311
0:13:56,8 --> 0:13:56,68
弓箭手

312
0:13:56,68 --> 0:13:58,28
他们还会有不同的武器

313
0:13:58,28 --> 0:14:0,95
比如说人类有对应的一些战士的武器啊

314
0:14:0,95 --> 0:14:2,87
精灵也会对应着战士的一些武器

315
0:14:2,87 --> 0:14:5,63
那么这个时候我们就需要产生一系列的产品足

316
0:14:5,63 --> 0:14:8,759
那么这个时候呢我们就应该要使用抽象工厂啊

317
0:14:8,759 --> 0:14:10,399
抽象工厂这里代码呢就比较复杂

318
0:14:10,399 --> 0:14:11,479
我就直接复制代码

319
0:14:11,479 --> 0:14:15,22
让帮助大家去进行一个理解和参考

320
0:14:15,38 --> 0:14:17,6
现在我们把代码复制到这边

321
0:14:17,6 --> 0:14:18,8
大家可以看到这里呢是抽象工厂

322
0:14:18,8 --> 0:14:21,28
抽象工厂呢它有一个抽象装备类

323
0:14:21,28 --> 0:14:22,72
以及具体的装备类

324
0:14:22,72 --> 0:14:24,34
我们在这里会增加一些剑呢

325
0:14:24,34 --> 0:14:26,19
还有增加一些盾牌啊

326
0:14:26,19 --> 0:14:28,97
这里的都是人类的使用的一些剑和盾牌

327
0:14:28,97 --> 0:14:31,61
那么这里呢还会有一些精灵所使用的一些

328
0:14:31,61 --> 0:14:34,319
弓和斗篷精灵

329
0:14:34,319 --> 0:14:38,49
这个这个就是精灵精灵所对应的武器好

330
0:14:38,49 --> 0:14:40,89
那么这里呢我们可能未来还会要进行一个扩展

331
0:14:40,89 --> 0:14:41,169
比如说还有一些兽人

332
0:14:41,169 --> 0:14:43,29
我们在这里呢暂时不添加

333
0:14:43,29 --> 0:14:46,34
接下来我们需要去创建一个种族工厂

334
0:14:46,34 --> 0:14:49,76
因为呢我们都是以种族为系列的种族战士

335
0:14:49,76 --> 0:14:50,85
种族精灵

336
0:14:50,85 --> 0:14:54,41
然后对应的种族对应着的一些武器好

337
0:14:54,41 --> 0:14:57,57
大家看到这个种族当中包括额种族的战士

338
0:14:57,57 --> 0:14:58,63
种族的精灵

339
0:14:58,63 --> 0:15:0,41
那么我们前面的具体的角色呢

340
0:15:0,41 --> 0:15:1,53
就变成了他的职业了

341
0:15:1,53 --> 0:15:1,99
对不对

342
0:15:1,99 --> 0:15:6,59
好他是战士还是一个弓箭手好

343
0:15:6,59 --> 0:15:7,71
那么大家可以看到

344
0:15:7,71 --> 0:15:11,7
然后我们再需要生成具体的种族角色类啊

345
0:15:11,7 --> 0:15:11,91
人类的

346
0:15:11,91 --> 0:15:13,53
人类的战士

347
0:15:13,53 --> 0:15:14,99
人类战士

348
0:15:14,99 --> 0:15:18,609
那么这个呢是精灵的弓箭手

349
0:15:18,929 --> 0:15:20,89
这个暂时不加

350
0:15:20,89 --> 0:15:22,41
这个是矮人呃兽人

351
0:15:22,69 --> 0:15:25,1
然后我们产生具体的一个工厂

352
0:15:25,1 --> 0:15:26,81
那么我们都是以种族为系列的

353
0:15:26,81 --> 0:15:28,19
比如说人族的工厂

354
0:15:28,19 --> 0:15:29,97
那要继承种族的工厂

355
0:15:29,97 --> 0:15:32,21
然后我们这里呢会去产生不同的

356
0:15:32,21 --> 0:15:33,45
比如说产生战士

357
0:15:33,45 --> 0:15:35,6
产生弓箭手

358
0:15:35,38 --> 0:15:38,76
以及产生它对应着人族的一些武器

359
0:15:38,76 --> 0:15:41,47
人族的一些内容好

360
0:15:41,47 --> 0:15:44,41
那么这里呢就是产生精灵相关的一些工厂

361
0:15:44,41 --> 0:15:47,48
那么精灵它对应的的战士

362
0:15:47,48 --> 0:15:48,6
精灵的弓箭手

363
0:15:48,6 --> 0:15:49,86
还有他对应的武器

364
0:15:49,86 --> 0:15:52,86
他的武器呢也是精灵对应的武器

365
0:15:52,86 --> 0:15:53,78
那么大家可以看到

366
0:15:53,78 --> 0:15:56,46
它就会把一系列相关联的对象呢

367
0:15:56,46 --> 0:15:59,62
通过统一的一个工厂把它们产生出来

368
0:15:59,62 --> 0:16:2,89
那么这样子其他人他就不会出现错误

369
0:16:2,89 --> 0:16:4,489
比如说其他程序员他在看你的代码的时候呃

370
0:16:4,489 --> 0:16:5,409
他去扩展的时候呢

371
0:16:5,409 --> 0:16:8,85
他就不会用人族使用精灵的一些武器

372
0:16:8,85 --> 0:16:9,89
就不会出现这样的问题

373
0:16:9,89 --> 0:16:11,17
通过这种抽象工厂呢

374
0:16:11,17 --> 0:16:13,9
就可以做到一个很好的限制好

375
0:16:13,9 --> 0:16:15,9
那么现在我们来理解一下

376
0:16:16,92 --> 0:16:17,88
简单工厂

377
0:16:17,88 --> 0:16:20,8
我们是通过参数来决定创建对象的实例

378
0:16:20,8 --> 0:16:22,66
通常对应的情况就是

379
0:16:22,66 --> 0:16:24,54
我们这个对象的创建比较简单

380
0:16:24,54 --> 0:16:27,36
而且呢我们的产品的类型

381
0:16:27,36 --> 0:16:29,78
它是经常不会发生改变的呃

382
0:16:29,78 --> 0:16:31,7
比较稳定的工厂方法呢

383
0:16:31,7 --> 0:16:33,66
对应的就是创建的流程比较复杂

384
0:16:33,66 --> 0:16:36,31
它包括生成以及初始化

385
0:16:36,31 --> 0:16:38,31
这流程呢我们要进行啊分离

386
0:16:38,31 --> 0:16:41,27
同时呢它的对应的需求就是我们的这个参呃

387
0:16:41,27 --> 0:16:44,23
就是这个角色他会动态的进行变化

388
0:16:44,23 --> 0:16:45,67
经常需要修改

389
0:16:45,67 --> 0:16:47,7
那么抽象工厂呢

390
0:16:47,7 --> 0:16:48,74
它对应解决的问题是

391
0:16:48,74 --> 0:16:51,12
创建相关和依赖对象的家族

392
0:16:51,12 --> 0:16:52,38
它是产生很多的产品

393
0:16:52,38 --> 0:16:53,16
一系列的产品

394
0:16:53,16 --> 0:16:55,319
这一系列产品之间是相互关联的

395
0:16:55,319 --> 0:16:56,719
那么这样子我们不需要

396
0:16:56,719 --> 0:16:59,439
我们只需要比如说我们只需要指定某一个种族

397
0:16:59,439 --> 0:17:4,58
然后它对应的一系列的这跟种族相关的绝职业

398
0:17:4,58 --> 0:17:5,96
以及他的武器

399
0:17:5,96 --> 0:17:9,609
那么我们都可以从他的这个抽象工厂里面呢

400
0:17:9,609 --> 0:17:10,489
去产生出来

401
0:17:10,489 --> 0:17:13,509
你不会去产生一个错误的种嗯

402
0:17:13,509 --> 0:17:16,349
种族的一些武器或者是职业

403
0:17:16,349 --> 0:17:19,469
好这个呢就是抽象工厂它所解决的问题

404
0:17:19,709 --> 0:17:22,229
最后我们来通过具体的案例来看

405
0:17:22,229 --> 0:17:25,349
上面的工厂模式呢是如何来使用的

406
0:17:26,12 --> 0:17:28,6
好我把代码呢直接复制过来了

407
0:17:32,4 --> 0:17:35,35
好大家看到这里呢是一个工厂模式的对比演示

408
0:17:35,35 --> 0:17:36,53
简单工厂

409
0:17:36,53 --> 0:17:39,31
那么我们直接通过simple character factory呢

410
0:17:39,31 --> 0:17:40,67
去创建这个角色

411
0:17:40,67 --> 0:17:41,55
那么这样子呢

412
0:17:41,55 --> 0:17:43,36
我们就直接得到了这样的一个对象

413
0:17:43,36 --> 0:17:45,14
那么还有一个呢就是工厂方法

414
0:17:45,14 --> 0:17:46,48
它是通过多态创建的

415
0:17:46,48 --> 0:17:47,9
通过子类进行实例化的

416
0:17:47,9 --> 0:17:49,98
那首先我们需要创建对应的工厂

417
0:17:49,98 --> 0:17:51,12
创建完工厂之后

418
0:17:51,12 --> 0:17:52,73
然后再去创建对应的角色

419
0:17:52,73 --> 0:17:54,1
这里创建角色的时候呢

420
0:17:54,1 --> 0:17:55,69
它是包含呃

421
0:17:55,69 --> 0:17:58,45
这里还要加上一个with set up

422
0:17:59,53 --> 0:18:1,9
With the help

423
0:18:1,41 --> 0:18:4,59
那么这里呢就包含这个战士的创建

424
0:18:4,59 --> 0:18:5,89
以及它的初始化流程

425
0:18:5,89 --> 0:18:7,99
都会在这里面呢会去进行产生

426
0:18:7,99 --> 0:18:10,64
然后我们再来看一下种族好产品

427
0:18:10,64 --> 0:18:11,76
抽象工厂的使用

428
0:18:11,76 --> 0:18:14,61
抽象工厂我们首先需要创建种族的工厂

429
0:18:14,61 --> 0:18:16,13
种族的工厂创建完之后

430
0:18:16,13 --> 0:18:18,41
这个种族的工厂里面包含他的职业

431
0:18:18,41 --> 0:18:19,97
以及他的对应的武器

432
0:18:19,97 --> 0:18:22,9
比如说我们创建战士

433
0:18:22,9 --> 0:18:23,61
创建武器好

434
0:18:23,61 --> 0:18:25,71
接着呢就把创建的结果呢输出出来

435
0:18:25,71 --> 0:18:27,81
现在我们来执行一下

436
0:18:38,56 --> 0:18:39,52
好再看到这里呢

437
0:18:39,52 --> 0:18:42,3
就是我们对应的工厂模式的对比演示

438
0:18:42,3 --> 0:18:45,69
简单工厂它的优点是实现简单使用方便

439
0:18:45,69 --> 0:18:47,81
缺点是违反开闭原则

440
0:18:47,81 --> 0:18:49,84
扩展需要修改工厂类

441
0:18:49,84 --> 0:18:51,26
然后呢就是工厂方法

442
0:18:51,26 --> 0:18:52,38
它是一种多态创建

443
0:18:52,38 --> 0:18:53,76
符合我们的开闭原则的

444
0:18:53,76 --> 0:18:54,88
那么同时它的缺点呢

445
0:18:54,88 --> 0:18:56,52
需要我们需要写很多的工厂类

446
0:18:56,52 --> 0:18:57,58
你有多少个种额

447
0:18:57,58 --> 0:18:58,32
有多少个角色

448
0:18:58,32 --> 0:18:59,64
我就要创建多少个嗯

449
0:18:59,64 --> 0:19:0,22
角色类

450
0:19:0,22 --> 0:19:1,76
那角色工厂类

451
0:19:1,76 --> 0:19:3,24
另外一个呢就是抽象工厂

452
0:19:3,24 --> 0:19:5,28
它是产生一系列的相关的产品

453
0:19:5,28 --> 0:19:7,6
那么呢额缺点是扩展产品足

454
0:19:7,6 --> 0:19:10,32
他就我们需要写很多的代码

455
0:19:10,96 --> 0:19:12,64
关于这个工厂方法呢

456
0:19:12,64 --> 0:19:13,68
我们就跟大家介绍到这

457
0:19:13,68 --> 0:19:16,2
如果大家需要本视频代码以及资料的朋友

458
0:19:16,2 --> 0:19:17,32
可以一键三连加关注

459
0:19:17,32 --> 0:19:18,88
谢谢大家

460
0:19:19,46 --> 0:19:22,64
现在给大家介绍一下我的LINUX7和C加

461
0:19:22,64 --> 0:19:23,98
全栈开发课程

462
0:19:23,98 --> 0:19:26,3
这个课程已经迭代了17次

463
0:19:26,3 --> 0:19:29,159
整个课程由11个专栏构成

464
0:19:29,159 --> 0:19:30,919
这个课程的主要目的是

465
0:19:30,919 --> 0:19:32,479
帮助大家构建一个完整的

466
0:19:32,479 --> 0:19:34,379
LINUX系和C加的知识体系

467
0:19:34,379 --> 0:19:38,159
我相信很多朋友如果是漫无目的的去学习

468
0:19:38,159 --> 0:19:41,79
那么我们在脑袋当中形成的是知识碎片

469
0:19:41,79 --> 0:19:42,639
它不利于记忆

470
0:19:42,639 --> 0:19:44,399
因为它们之间是没有联系的

471
0:19:44,399 --> 0:19:45,559
那么通过课程的学习呢

472
0:19:45,559 --> 0:19:49,39
我们会把各个知识点给大家搭建一个联系

473
0:19:49,39 --> 0:19:51,16
然后形成一个技术站好

474
0:19:51,16 --> 0:19:54,26
那么我们先来看一下这11个主题

475
0:19:54,26 --> 0:19:56,28
第一个主题呢是精进基石专栏

476
0:19:56,28 --> 0:19:59,22
这个专栏呢里面包含着我们开发当中

477
0:19:59,22 --> 0:20:0,46
常用的数据结构

478
0:20:0,46 --> 0:20:3,17
还有就是核心组件的数据结构

479
0:20:3,17 --> 0:20:5,9
像红黑树B树B加数

480
0:20:5,9 --> 0:20:7,73
以及呢散列表不能过滤器位图

481
0:20:7,73 --> 0:20:10,1
分布式异性哈希等等

482
0:20:10,1 --> 0:20:11,93
接下来就是设计模式

483
0:20:11,93 --> 0:20:13,35
这里呢会跟大家介绍

484
0:20:13,35 --> 0:20:16,65
工作当中常用的十多个设计模式

485
0:20:17,5 --> 0:20:21,13
C加新特性是在西加九八之后的一些特性

486
0:20:21,13 --> 0:20:23,21
C加十一十四十720

487
0:20:23,21 --> 0:20:26,605
那重点呢需要掌握十一十四十七

488
0:20:27,209 --> 0:20:28,949
最后是LINUX工程管理

489
0:20:28,949 --> 0:20:31,469
这里重点会介绍新make

490
0:20:31,469 --> 0:20:32,929
也就是我们的项目组织

491
0:20:32,929 --> 0:20:34,429
还有呢就是get it

492
0:20:34,429 --> 0:20:38,9
也就是我们未来工作当中协同开发的常用工具

493
0:20:38,9 --> 0:20:40,81
我们还需要掌握一些LINUX常用命令

494
0:20:40,81 --> 0:20:44,17
以及我们需要掌握GDP调试

495
0:20:44,26 --> 0:20:47,2
第二部分是高性能网络设计专栏

496
0:20:47,2 --> 0:20:48,82
这里有两个部分构成

497
0:20:48,82 --> 0:20:50,16
一个呢是网络编程

498
0:20:50,16 --> 0:20:52,3
另外一个呢是网络原理

499
0:20:52,3 --> 0:20:55,43
网络编程部分我们需要掌握同步I/O reactor

500
0:20:55,43 --> 0:20:56,5
网络模型

501
0:20:56,5 --> 0:20:57,95
异步IOPROACT网络模型

502
0:20:57,95 --> 0:21:0,72
像IOURIOCP

503
0:21:1,8 --> 0:21:3,0
同时网络原理呢是我们面试当中

504
0:21:3,0 --> 0:21:4,76
常问的一些网络细节问题

505
0:21:4,76 --> 0:21:8,23
这里呢我们重点介绍的是LINUX内核协议栈的原理

506
0:21:8,23 --> 0:21:12,15
还有我们还会带领大家手把手实现协程框架

507
0:21:12,15 --> 0:21:13,63
我相信很多朋友应该知道

508
0:21:13,63 --> 0:21:15,33
面试当中常问这些问题

509
0:21:15,33 --> 0:21:19,1
以及我们会基于DDK去实现用户态协议站

510
0:21:19,21 --> 0:21:21,3
这个呢是网络设计专栏

511
0:21:21,3 --> 0:21:23,55
第三个部分是基础组件设计专栏

512
0:21:23,55 --> 0:21:25,81
我们会带领大家用mod77加

513
0:21:25,81 --> 0:21:29,89
也就是十一十四十七来实现常用的轮子

514
0:21:29,89 --> 0:21:31,33
也就是我们去造这些轮子

515
0:21:31,33 --> 0:21:32,97
包括直视组件

516
0:21:32,97 --> 0:21:34,76
像无锁队列

517
0:21:34,76 --> 0:21:37,16
因为在网络环境去设计定时器

518
0:21:37,16 --> 0:21:38,32
设计死锁

519
0:21:38,32 --> 0:21:41,72
检测内存泄漏检测的一些组件等等

520
0:21:41,72 --> 0:21:44,3
第四部分是中间件开发专栏

521
0:21:44,3 --> 0:21:47,11
这里呢会重点介绍REDIS

522
0:21:47,11 --> 0:21:47,63
Mysql

523
0:21:47,63 --> 0:21:49,63
卡夫卡GRPCNIMX等等

524
0:21:49,63 --> 0:21:53,449
那么这些也是我们开发当中常用的一些中间件

525
0:21:53,449 --> 0:21:56,109
加rise是内存数据库

526
0:21:56,109 --> 0:21:57,29
Nosl

527
0:21:57,29 --> 0:21:59,32
MYSQL是关系型数据库

528
0:21:59,56 --> 0:22:2,32
像卡夫卡GRPC animals

529
0:22:2,32 --> 0:22:3,0
这个呢

530
0:22:3,0 --> 0:22:6,469
也是我们工作当中常会遇到的一些中间件

531
0:22:6,469 --> 0:22:8,609
第五部分是开源框架专栏

532
0:22:8,609 --> 0:22:11,9
它是由前面知识点的一个综合

533
0:22:11,9 --> 0:22:13,47
我们开源框架或者说框架

534
0:22:13,47 --> 0:22:17,47
它是基于多个技术点综合起来提出一个模型

535
0:22:17,47 --> 0:22:19,17
去解决具体的业务场景

536
0:22:19,17 --> 0:22:22,94
向游戏方向的scanner实现了一个actor并发模型

537
0:22:22,94 --> 0:22:25,46
还有ANIMX在OpenAI

538
0:22:25,46 --> 0:22:28,64
在ANIMX上去抽象一个LUA虚拟机

539
0:22:28,64 --> 0:22:32,2
然后方便我们在ANIMX上面呢去做一些开发

540
0:22:32,48 --> 0:22:37,0
还有像workflow就是异步流的一种编程方式等等

541
0:22:37,0 --> 0:22:39,63
第六部分是云原声专栏

542
0:22:39,63 --> 0:22:41,55
前面部分呢是帮助我们怎么开发

543
0:22:41,55 --> 0:22:44,31
接下来呢我们要基于开发之后去发布到线上

544
0:22:44,31 --> 0:22:46,74
那这里会介绍doc和库巴斯

545
0:22:46,74 --> 0:22:49,1
第七个部分是性能分析专栏

546
0:22:49,1 --> 0:22:51,98
那这里会带领大家去学习啊

547
0:22:51,98 --> 0:22:53,929
我们性能测试常用的一些工具

548
0:22:53,929 --> 0:22:55,849
还有呢学习观测技术

549
0:22:55,849 --> 0:22:57,6
BTF和EBBF

550
0:22:57,6 --> 0:23:1,2
同时我们也需要去了解我们平常开发当中

551
0:23:1,2 --> 0:23:3,2
所涉及到的一些内核知识

552
0:23:3,2 --> 0:23:5,2
那么我们会带领大家学习内核源码

553
0:23:5,2 --> 0:23:7,72
这个内核源码呢在对于开发而言

554
0:23:7,72 --> 0:23:9,26
需要掌握四个方面

555
0:23:9,26 --> 0:23:10,54
第一个呢是网络

556
0:23:10,54 --> 0:23:13,58
还有一个呢就是进程调度相关的内存管理

557
0:23:13,58 --> 0:23:16,57
相关的文件系统相关的

558
0:23:16,93 --> 0:23:19,21
第八个部分是分布式架构专栏

559
0:23:19,21 --> 0:23:22,41
我们会通过分布式的一些常用的工具

560
0:23:22,41 --> 0:23:23,45
像数据库

561
0:23:23,45 --> 0:23:24,69
分布式的文件系统

562
0:23:24,69 --> 0:23:26,18
分布式的协同等等

563
0:23:26,18 --> 0:23:27,44
分布式监控等等

564
0:23:27,44 --> 0:23:29,86
来帮助大家理解分布式的一个

565
0:23:29,86 --> 0:23:33,8
他要去关注的问题和解决的问题

566
0:23:33,8 --> 0:23:36,36
最后我们会通过多个项目来巩固

567
0:23:36,36 --> 0:23:38,28
前面所掌握的知识点

568
0:23:38,28 --> 0:23:38,92
当然了

569
0:23:38,92 --> 0:23:42,48
这些知识点的学习呢是通过规划一步一步来的

570
0:23:42,48 --> 0:23:44,68
我们会针对每一个学员的情况

571
0:23:44,68 --> 0:23:46,3
来进行一个规划好

572
0:23:46,3 --> 0:23:46,78
那你可以看到

573
0:23:46,78 --> 0:23:51,4
我们会为每一个学员呢去形成一个成长轨迹

574
0:23:51,4 --> 0:23:52,96
去记录他的成长轨迹

575
0:23:52,96 --> 0:23:55,46
好我们随便看一个学员

576
0:23:55,9 --> 0:23:57,58
当加入课程学习的时候

577
0:23:57,58 --> 0:24:0,4
我们就会去制定一个详细的学习计划

578
0:24:0,4 --> 0:24:1,4
根据他的情况

579
0:24:1,4 --> 0:24:4,56
然后呢会针对每一个专栏的学习

580
0:24:4,56 --> 0:24:6,72
我们会去进行一个技术摸底

581
0:24:6,72 --> 0:24:11,8
技术摸底的作用是帮助大家去理解技术点

582
0:24:11,8 --> 0:24:12,78
帮大家梳理这些技术点

583
0:24:12,78 --> 0:24:15,66
同时呢去纠正大家对这个技术理解的偏差

584
0:24:15,66 --> 0:24:20,15
还有呢就是锻炼大家在面试的的一些技巧

585
0:24:20,15 --> 0:24:23,75
我们每一个技术摸底都会形成一个录音

586
0:24:23,75 --> 0:24:25,39
那方便大家进行一个复盘

587
0:24:25,39 --> 0:24:27,52
同时呢我会根据大家面试

588
0:24:27,52 --> 0:24:29,76
当中就是摸底过程当中的一些问题呢

589
0:24:29,76 --> 0:24:31,8
提出一些建议

590
0:24:31,8 --> 0:24:34,4
那么大家可以看到在这里呢会有整个流程

591
0:24:34,4 --> 0:24:37,47
就是大家从开始学习简历修改

592
0:24:37,47 --> 0:24:41,37
面试复盘会形成一个你的学习路径

593
0:24:41,37 --> 0:24:44,29
那么大家能够看到自己的成长

594
0:24:44,49 --> 0:24:46,53
最后如果大家有兴趣的朋友呢

595
0:24:46,53 --> 0:24:47,85
可以来咨询一下课程

596
0:24:47,85 --> 0:24:48,8
谢谢大家

