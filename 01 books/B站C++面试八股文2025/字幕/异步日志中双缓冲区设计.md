1
0:0:0,7 --> 0:0:1,6
Hello

2
0:0:1,6 --> 0:0:1,46
大家好

3
0:0:1,46 --> 0:0:2,1
我是马克

4
0:0:2,1 --> 0:0:3,94
今天跟大家分享一个项目

5
0:0:3,94 --> 0:0:7,369
面经异步日志中双缓冲区设计

6
0:0:7,369 --> 0:0:10,669
这个题目来源于一位网友43991面

7
0:0:10,669 --> 0:0:14,62
他的第二个项目日志器的问答里面

8
0:0:14,62 --> 0:0:15,74
提到了双缓冲区

9
0:0:15,74 --> 0:0:16,8
我马上想到了

10
0:0:16,8 --> 0:0:20,3
应该是墨多当中异步日志器的实现

11
0:0:20,3 --> 0:0:21,33
在mod库当中

12
0:0:21,33 --> 0:0:24,13
它是采用双缓冲区来进行实现的

13
0:0:24,13 --> 0:0:27,27
所以呢我把里面的代码进行一个剥离

14
0:0:27,27 --> 0:0:28,57
重新实现了一遍

15
0:0:28,57 --> 0:0:32,59
用C加14去掉了墨多当中的一些项目依赖

16
0:0:32,59 --> 0:0:34,97
同时呢我把里面的fix buffer

17
0:0:34,97 --> 0:0:38,43
重新采用unique pdr来进行了一个实现

18
0:0:38,43 --> 0:0:42,25
以及mod库当中还会有一些注释优化

19
0:0:42,25 --> 0:0:44,2
我也把它进行了一个实现

20
0:0:44,2 --> 0:0:47,24
因为它的注释当中提到了用write v来进行优化

21
0:0:47,24 --> 0:0:51,27
那么我干脆用write v把这一段数据写入的逻辑呢

22
0:0:51,27 --> 0:0:52,5
重新实现了一遍

23
0:0:52,5 --> 0:0:54,7
大家需要本视频资料

24
0:0:54,7 --> 0:0:58,7
包括这个项目的朋友可以一键三连加关注

25
0:0:59,1 --> 0:1:0,64
获取本视频资料

26
0:1:0,64 --> 0:1:3,78
那么我们从双缓冲区设计出发

27
0:1:3,78 --> 0:1:6,63
来给大家说一下参考回答

28
0:1:6,63 --> 0:1:9,35
首先我们采用总分的形式

29
0:1:9,35 --> 0:1:14,42
第一部分异步日志系统的核心是双缓冲区设计

30
0:1:14,42 --> 0:1:17,12
然后我们要点出生产消费模型

31
0:1:17,12 --> 0:1:18,56
因为呢它是异步日志

32
0:1:18,56 --> 0:1:21,78
所以呢我们会把生产者线程跟消费者线程呢

33
0:1:21,78 --> 0:1:23,3
进行一个解耦

34
0:1:23,3 --> 0:1:26,68
生产业务线程写入current buffer时

35
0:1:26,68 --> 0:1:28,56
不需要等待IO操作

36
0:1:28,56 --> 0:1:30,22
这里呢点出了我们的特色

37
0:1:30,22 --> 0:1:32,34
就是异步解耦低延迟

38
0:1:32,34 --> 0:1:34,36
当缓冲区写满后

39
0:1:34,36 --> 0:1:38,61
立即切换到预备的NEBUFFER继续写入

40
0:1:38,61 --> 0:1:41,9
这里呢提到了我们的双缓冲区

41
0:1:41,9 --> 0:1:43,17
以及我们的第二个缓冲区的作用

42
0:1:43,17 --> 0:1:45,78
它是作为一个预备的buffer

43
0:1:45,78 --> 0:1:48,88
这样子呢可以实现一个高吞吐

44
0:1:48,88 --> 0:1:52,46
因为我们不会在切换的时候呢

45
0:1:52,46 --> 0:1:55,41
呃需要等待这个内存分配

46
0:1:55,41 --> 0:1:59,79
同时将以满缓冲区移入待处理队列

47
0:1:59,79 --> 0:2:1,75
因为我们是一个生产消费模型

48
0:2:1,75 --> 0:2:4,0
通常的都会对应着一个队列

49
0:2:4,0 --> 0:2:7,7
消费者线程则负责批量将这些缓冲区数据

50
0:2:7,7 --> 0:2:8,62
写入磁盘

51
0:2:8,62 --> 0:2:12,329
那么这至此我们回答了三个点

52
0:2:12,329 --> 0:2:16,19
第一个点我们回答了它的核心

53
0:2:16,19 --> 0:2:18,73
第二个点回答了生产消费模型

54
0:2:18,73 --> 0:2:21,92
第三个点回答了双缓冲区的设计

55
0:2:21,92 --> 0:2:27,98
那么接下来呢我们可以去点出双缓冲区

56
0:2:27,98 --> 0:2:29,12
它的一特色

57
0:2:29,12 --> 0:2:32,75
通过这种设计空间换时间

58
0:2:32,75 --> 0:2:35,67
实现了协操作无阻塞

59
0:2:35,67 --> 0:2:40,32
因为生产线程永远不会因为磁盘IO而停滞

60
0:2:40,32 --> 0:2:41,96
批量写入的优化

61
0:2:41,96 --> 0:2:45,339
因为呢我们会减少系统的调用次数

62
0:2:45,339 --> 0:2:48,859
我们是等待next current buffer满了之后

63
0:2:48,859 --> 0:2:50,739
我们才会去进行一个切换

64
0:2:50,739 --> 0:2:54,87
同时通知消费线程呢去进行写入磁盘

65
0:2:55,89 --> 0:2:57,53
另外一个是内存复用

66
0:2:57,53 --> 0:2:59,1
通过缓冲区池化

67
0:2:59,1 --> 0:3:0,83
避免频繁的内存分配

68
0:3:0,83 --> 0:3:3,39
那么我们可以举例子呢进行一个阐述

69
0:3:3,39 --> 0:3:5,23
当current buffer写满时

70
0:3:5,23 --> 0:3:6,71
我们不是立即进行写入

71
0:3:6,71 --> 0:3:10,81
而是通过移动语义来快速的切换缓冲区

72
0:3:10,81 --> 0:3:12,91
好那么这里呢涉及到移动语义呢

73
0:3:12,91 --> 0:3:15,99
所以我把model库当中的fix buffer呢

74
0:3:15,99 --> 0:3:18,81
实现成从堆上去分配

75
0:3:18,81 --> 0:3:21,27
那么这样子呢方便我们进行数据移动

76
0:3:21,27 --> 0:3:24,1
这个过程使涉及到指针操作

77
0:3:24,1 --> 0:3:25,37
没有内存拷贝

78
0:3:25,37 --> 0:3:29,11
消费线程则通过rev系统调用进行批量写入

79
0:3:29,11 --> 0:3:30,73
即使遇到部分写入的情况

80
0:3:30,73 --> 0:3:32,29
也能够正确处理好

81
0:3:32,29 --> 0:3:36,17
这个呢是关于red v逻辑的实现进行一个点出

82
0:3:37,37 --> 0:3:39,27
那么接下来我们来了解一下

83
0:3:39,27 --> 0:3:43,18
整个双缓冲区的一个设计

84
0:3:43,18 --> 0:3:46,16
蓝色部分对应的都是我们的生产线程

85
0:3:46,16 --> 0:3:48,9
绿色的部分对应的是我们的消费者线程

86
0:3:48,9 --> 0:3:49,959
操作的部分

87
0:3:49,959 --> 0:3:52,159
生产者线程当中我们有两个buffer

88
0:3:52,159 --> 0:3:53,39
一个current buffer

89
0:3:53,39 --> 0:3:54,219
一个呢next buffer

90
0:3:54,219 --> 0:3:55,959
current buffer写满的时候

91
0:3:55,959 --> 0:3:56,419
那么呢

92
0:3:56,419 --> 0:4:0,56
我们会把KAMBUBER的数据移动到这个队列当中

93
0:4:0,56 --> 0:4:4,91
同时我们会进行一个预备缓冲区的一个交换

94
0:4:4,91 --> 0:4:9,67
我们把预备的缓冲区move到我们的current buffer

95
0:4:9,99 --> 0:4:12,35
那么接下来就是我们的消费者线程

96
0:4:12,35 --> 0:4:15,23
消费者线程呢它会进行一个swap

97
0:4:15,23 --> 0:4:19,57
把这个队列呃交换到buffer to write啊

98
0:4:19,57 --> 0:4:23,5
那我们什么消费者线程怎么来发生交换呢

99
0:4:23,5 --> 0:4:24,27
这里有两种情况

100
0:4:24,27 --> 0:4:26,25
第一种情况呢就是他满的时候

101
0:4:26,25 --> 0:4:28,659
他会通过条件变量来通知

102
0:4:28,659 --> 0:4:31,64
同时呢我们可能这个current buffer

103
0:4:31,64 --> 0:4:34,66
也就是消费者和生产者生产的数据比较少

104
0:4:34,66 --> 0:4:36,74
那么我们这里呢会有一个超时机制

105
0:4:36,74 --> 0:4:38,9
比如说三秒之后

106
0:4:38,9 --> 0:4:40,27
那么我们会把current buffer的数据呢

107
0:4:40,27 --> 0:4:41,37
挪到这个buffer

108
0:4:41,37 --> 0:4:44,21
同时完成一个交换

109
0:4:44,21 --> 0:4:46,55
那么我们刚刚current buffer

110
0:4:46,55 --> 0:4:48,89
它会放到这个buffers里面

111
0:4:48,89 --> 0:4:53,15
那么呢我们消费者线程这边也会准备

112
0:4:53,15 --> 0:4:55,7
new buffer1和new buffer2

113
0:4:55,7 --> 0:4:58,19
new buffer1呢也是一个预备的缓冲区

114
0:4:58,19 --> 0:5:0,69
用于移动到我们的kern buffer

115
0:5:0,69 --> 0:5:1,49
New buffer

116
0:5:1,49 --> 0:5:3,71
二呢它也是一个预备buffer

117
0:5:3,71 --> 0:5:6,869
它会移动到我们的next buffer

118
0:5:6,869 --> 0:5:10,629
好这样子呢我们就在整个生产消费模型当中呢

119
0:5:10,629 --> 0:5:17,83
不会出现新的缓冲趋势去再去进行生成

120
0:5:18,19 --> 0:5:19,93
那么呢大家可以看到

121
0:5:19,93 --> 0:5:23,77
我们这里呢缓冲区会涉及到大量的移动操作

122
0:5:23,77 --> 0:5:28,6
所以呢我们把那个fix buffer呢重新实现了一下

123
0:5:28,6 --> 0:5:31,38
好那么我们在这里呢双缓中的特色

124
0:5:31,38 --> 0:5:33,23
第一个呢是异步解耦好

125
0:5:33,23 --> 0:5:35,3
我们的日志生产和日志消费

126
0:5:35,3 --> 0:5:37,7
进行分别的进行处理啊

127
0:5:37,7 --> 0:5:38,96
分屏的线程处理

128
0:5:38,96 --> 0:5:41,3
那么我们的生产线程可能多个消费者

129
0:5:41,3 --> 0:5:43,64
线程的只有一个低延迟

130
0:5:43,64 --> 0:5:48,839
好每次避免每次日志写入都触发IO操作

131
0:5:48,839 --> 0:5:50,339
减少线程阻塞

132
0:5:50,339 --> 0:5:52,58
而且呢我们在这里的IO操作呢

133
0:5:52,58 --> 0:5:53,76
还包括内存分配

134
0:5:53,76 --> 0:5:55,38
大家可以看到这个内存分配呢

135
0:5:55,38 --> 0:5:56,89
我们也在尽量的避免

136
0:5:56,89 --> 0:6:0,71
因为我们会有预备线程不断的去进行填充

137
0:6:0,71 --> 0:6:4,75
比如说next buffer是can buffer的一个预备队列

138
0:6:4,75 --> 0:6:8,93
new buffer1是canon buffer的预备缓冲区

139
0:6:8,93 --> 0:6:12,62
new buffer2是next buffer的预分配缓冲区

140
0:6:12,62 --> 0:6:15,54
那么我们的new buffer1和new buffer2

141
0:6:15,54 --> 0:6:19,12
它的预备呢它的预备是在buffer to write当中

142
0:6:19,12 --> 0:6:22,28
这些缓冲区我们也会合理进行利用好

143
0:6:22,28 --> 0:6:24,4
去进行预备

144
0:6:24,75 --> 0:6:28,19
那么这样子呢我们在整个生产消费的过程当中

145
0:6:28,19 --> 0:6:31,27
就尽量避免了内存分配

146
0:6:32,459 --> 0:6:33,299
高吞吐

147
0:6:33,299 --> 0:6:38,82
我们批量的处理数日志数据提高了写入效率啊

148
0:6:38,82 --> 0:6:42,77
批量处理是我们这里满了之后才去写

149
0:6:42,77 --> 0:6:45,33
同时呢如果我们的生产速度过快的话

150
0:6:45,33 --> 0:6:47,87
那么呢我们这里呢会有一个队列进行堆积

151
0:6:47,87 --> 0:6:48,69
堆积之后

152
0:6:48,69 --> 0:6:50,91
那么我们在啊进行一个交换

153
0:6:50,91 --> 0:6:51,57
交换之后

154
0:6:51,57 --> 0:6:54,83
我们在这个buffer to write当中呢不断的去写呃

155
0:6:54,83 --> 0:6:58,51
在这个消费者线程当中去刷盘

156
0:6:58,79 --> 0:6:59,85
线程安全

157
0:6:59,85 --> 0:7:1,99
我们通过缓冲区交换机制

158
0:7:1,99 --> 0:7:3,57
减少了锁竞争

159
0:7:3,57 --> 0:7:8,59
而我们尽量这个锁的占用时间比较少好

160
0:7:8,59 --> 0:7:11,19
那么大家可以看到生产者线程两个队列

161
0:7:11,19 --> 0:7:12,89
这啊两个缓冲区

162
0:7:12,89 --> 0:7:16,7
这两个缓冲区呢是接收来自业务线程的一个

163
0:7:16,7 --> 0:7:16,69
日志数据

164
0:7:16,69 --> 0:7:19,27
也就是我们的生产线程的日志数据

165
0:7:19,27 --> 0:7:20,55
那么大家可以看到

166
0:7:20,55 --> 0:7:22,41
当我们这里写满了之后

167
0:7:22,41 --> 0:7:27,3
我们就会去通过一个条件变量去唤醒

168
0:7:27,3 --> 0:7:28,33
唤醒我们的消费者

169
0:7:28,33 --> 0:7:30,62
线程呢去进行一个刷盘

170
0:7:30,62 --> 0:7:33,18
消费者线程呢这里呢会有一个buffers

171
0:7:33,18 --> 0:7:34,38
对应着一个buffers

172
0:7:34,38 --> 0:7:36,6
同时呢我们在站上面呢

173
0:7:36,6 --> 0:7:40,92
也会维持维持一个buffer to write好去进行一个交换

174
0:7:40,92 --> 0:7:41,78
交换之后

175
0:7:41,78 --> 0:7:45,94
我们基于这个buffer to write呢去进行数据写入

176
0:7:46,92 --> 0:7:50,22
好那么还有一个呢就是我们这里呢等待三秒

177
0:7:50,22 --> 0:7:52,29
如果三秒钟过后

178
0:7:52,29 --> 0:7:53,59
那么会进行超时

179
0:7:53,59 --> 0:7:54,15
超时呢

180
0:7:54,15 --> 0:7:57,3
我们会看看当前的karen buffer是不是有数据

181
0:7:57,3 --> 0:7:58,31
如果没有数据的话

182
0:7:58,31 --> 0:8:0,39
我们继续进行一个休眠

183
0:8:0,39 --> 0:8:1,27
否则的话

184
0:8:1,27 --> 0:8:3,43
我们就会把carry buffer里面的数据呢

185
0:8:3,43 --> 0:8:5,11
去进行一个刷盘

186
0:8:5,43 --> 0:8:9,25
那么可能呢它会进行一个问题的一个扩展

187
0:8:9,25 --> 0:8:13,68
如果日志生产速度持续大于消费速度怎么办

188
0:8:13,68 --> 0:8:16,66
那么这里呢我们会设计了一个动态缓冲区分配

189
0:8:16,66 --> 0:8:17,4
也就是buffers

190
0:8:17,4 --> 0:8:19,85
他可以动态的增长啊

191
0:8:19,85 --> 0:8:23,5
那么当然呢我们可能会根据生产环境的需要

192
0:8:23,5 --> 0:8:25,51
增加报警机制或者流控策略

193
0:8:25,51 --> 0:8:27,57
比如说我们这里

194
0:8:29,16 --> 0:8:31,8
当大于25的时候

195
0:8:31,8 --> 0:8:33,16
这个mod库当中也有提到好

196
0:8:33,16 --> 0:8:35,72
我们这里呢需要进行一个留空处理

197
0:8:35,72 --> 0:8:41,69
同时为什么选择四兆的缓冲区大小啊

198
0:8:41,69 --> 0:8:44,25
那么大家需要注意这个是页的倍数

199
0:8:44,25 --> 0:8:46,1
页的大小的倍数

200
0:8:46,25 --> 0:8:48,53
那如何保证日志的顺序

201
0:8:48,53 --> 0:8:50,95
因为呢我们的消费者线程只有一个

202
0:8:50,95 --> 0:8:52,89
同时呢我们准备了一个队列

203
0:8:52,89 --> 0:8:55,3
那么队列呢是先进先出的

204
0:8:55,3 --> 0:8:58,61
所以呢严格按照入队的顺序进行写入的

205
0:8:58,61 --> 0:9:0,79
有哪些关键的优化点

206
0:9:0,79 --> 0:9:2,59
第一个呢是fix buffer

207
0:9:2,59 --> 0:9:4,59
采用了unique ptr来实现

208
0:9:4,59 --> 0:9:7,21
确保零拷贝的缓冲区交换

209
0:9:7,21 --> 0:9:9,88
避免了内存拷贝带来的性能损失

210
0:9:9,88 --> 0:9:12,48
还有一个呢双预备缓冲区的设计呢

211
0:9:12,48 --> 0:9:15,96
是确保始终保留两个空闲的缓冲区

212
0:9:15,96 --> 0:9:20,66
好大家可以看到在这里呢啊我们的预备关系

213
0:9:20,66 --> 0:9:22,829
next buffer是他的预备

214
0:9:22,829 --> 0:9:25,769
new buffer1是karen buffer的预备

215
0:9:25,769 --> 0:9:28,79
new buffer2是next buffer的预备

216
0:9:28,79 --> 0:9:31,1
那么我们这里的buffer to write

217
0:9:31,1 --> 0:9:33,31
这里我们始终会确保有两个

218
0:9:33,31 --> 0:9:35,11
大家可以看到好

219
0:9:35,11 --> 0:9:37,45
我们这里呢始终确保它有两个

220
0:9:37,45 --> 0:9:38,67
有两个之后呢

221
0:9:38,67 --> 0:9:42,96
好我们是new buffer1的预备

222
0:9:42,96 --> 0:9:44,92
它是new buffer2的预备

223
0:9:44,92 --> 0:9:46,14
通过这种方式呢

224
0:9:46,14 --> 0:9:48,92
我们尽量避免在整个生产消费当中

225
0:9:48,92 --> 0:9:51,74
去生成新的buffer

226
0:9:51,74 --> 0:9:54,6
当然呢如果生产的速度比较快的时候

227
0:9:54,6 --> 0:9:59,67
仍然有可能去再去要分配我们的buffer

228
0:10:1,79 --> 0:10:5,85
另外一个呢是采用了rev进行批量的写入

229
0:10:5,85 --> 0:10:6,99
减少系统调用

230
0:10:6,99 --> 0:10:9,19
这个呢是我额外实现的一个逻辑

231
0:10:9,19 --> 0:10:10,46
大家可以看到

232
0:10:10,46 --> 0:10:12,46
因为我们的这个buffer to write呢

233
0:10:12,46 --> 0:10:14,56
里面可能会有多个缓冲区

234
0:10:14,56 --> 0:10:16,78
就是如果生产的速度大于消费者的速度

235
0:10:16,78 --> 0:10:17,6
那么这个时候呢

236
0:10:17,6 --> 0:10:20,12
这个Buff to write里面的会堆积很多数据

237
0:10:20,12 --> 0:10:21,94
那么我们在这里呢采用red v

238
0:10:21,94 --> 0:10:22,72
right v呢

239
0:10:22,72 --> 0:10:26,8
是把离散的数据写到我们的缓冲区内核里面

240
0:10:26,8 --> 0:10:29,2
连续的缓冲区好

241
0:10:29,2 --> 0:10:31,97
那么red v呢这是准备了多个好

242
0:10:31,97 --> 0:10:35,53
我们离散的这些地址是离散地址是离散的

243
0:10:35,53 --> 0:10:38,72
我们把它进行一个合并写入好

244
0:10:38,72 --> 0:10:40,88
那么当然呢在这里面可能会失败

245
0:10:40,88 --> 0:10:42,3
只写入到部分数据

246
0:10:42,3 --> 0:10:44,3
N呢是实际写入的数据

247
0:10:44,3 --> 0:10:48,86
好这里呢是我们预期呃里面的预期写的数据

248
0:10:48,86 --> 0:10:51,56
那么我们可能只写一部分数据

249
0:10:51,56 --> 0:10:53,66
那么因为我们这里呢只有一个线程

250
0:10:53,66 --> 0:10:55,6
那么我们仍然采用阻塞的方式呢

251
0:10:55,6 --> 0:10:57,95
依次把数据呢写出去

252
0:10:58,27 --> 0:10:59,37
写出去之后

253
0:10:59,37 --> 0:11:2,53
接下来呢我们需要把这种啊new buffer

254
0:11:2,53 --> 0:11:3,51
New buffer2

255
0:11:3,51 --> 0:11:6,43
把它预备的去进行一个移动

256
0:11:6,43 --> 0:11:9,27
整体实现呢就跟大家介绍到这

257
0:11:9,27 --> 0:11:11,85
大家需要资料的朋友呢可以一键三连加关注

258
0:11:11,85 --> 0:11:12,9
谢谢大家

